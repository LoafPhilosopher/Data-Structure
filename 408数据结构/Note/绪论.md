# 数据结构的定义

## 基本概念和术语

### 数据

数据是信息的载体,是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。

### 数据元素

**数据元素是数据的基本单位**,通常作为一个整体进行考虑和处理。**一个数据元素可由若干数据项组成**,**数据项是构成数据元素的不可分割的最小单位**。

### 数据对象

数据对象是具有相同性质的数据元素的集合,是数据的一个子集。例如：整数数据对象是集合$N=\{0,\pm1,\pm2,...\}$。

### 数据类型

数据类型是一个值的集合和定义在此集合上的一组操作的总称。

- 原子类型：其值不可再分的数据类型
- 结构类型：其值可以再分解为若干成分（分量）的数据类型。
- 抽象数据类型：抽象数据组织及与之相关的操作
  ![20240326145056](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240326145056.png)

### 数据结构

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中,数据元素都不是孤立存在的,它们之间存在某种关系,这种**数据元素相互之间的关系称为结构(Structure)**。**数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算**。
数据结构关注的是数据的结构特性以及数据之间的相互关系,并不关注数据的具体内容。
数据的逻辑结构和存储结构是密不可分的两个方面,一个算法的设计取决于所选定的逻辑结构,而算法的实现依赖于所采用的存储结构。
需要注意的是：对任何数据结构进行相应的操作之后,都不能改变原有的数据结构特点[^1]

[^1]: 即单链表删除一个元素后不会变成双链表

> 需要注意的是数据结构无明确定义。

## 数据结构三要素

### <font color="red">逻辑结构</font>

逻辑结构是指数据元素之间的逻辑关系,即从逻辑关系上描述数据。它与数据的存储无关,是独立于计算机的。**数据的逻辑结构分为线性结构和非线性结构,线性表是典型的线性结构；集合、树和图是典型的非线性结构。可以用多种存储结构实现同一种逻辑结构**。
![20231206144302](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20231206144302.png)

### <font color="red">存储结构</font>

**存储结构是指数据结构在计算机中的表示(又称映像),也称物理结构**。它包括数据元素的表示和关系的表示。**数据的存储结构是用计算机语言实现的逻辑结构**,它依赖于计算机语言。**数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储**。
![20240326150026](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240326150026.png)

#### 顺序顺序存储

**把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中**,元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取,每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元,因此可能产生较多的外部碎片。

#### 链式存储

**不要求逻辑上相邻的元素在物理位置上也相邻,借助指示元素存储地址的指针来表示元素之间的逻辑关系**。其优点是不会出现碎片现象,能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间,且只能实现顺序存取。

#### 索引存储

**在存储元素信息的同时,还建立附加的索引表**。索引表中的每项称为索引项,索引项的一般形式是（关键字,地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外,增加和删除数据时也要修改索引表,因而会花费较多的时间。

#### 散列存储

**根据元素的关键字直接计算出该元素的存储地址,又称哈希（Hash）存储**。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好,则可能出现元素存储单元的冲突,而解决冲突会增加时间和空间开销。

### 数据的运算

施加在数据上的运算包括运算的定义和实现。**运算的定义是针对逻辑结构的,指出运算的功能；运算的实现是针对存储结构的,指出运算的具体操作步骤。**

# 算法

## 算法的概念

### 定义

**算法是对特定问题求解步骤的一种描述**,它是指令的有限序列,其中的每条指令表示一个或多个操作。

### 算法的特征

- 有穷性：一个算法必须总在执行有穷步之后结束,且每一步都可在有穷时间内完成[^2]
- 确定性：算法中每条指令必须有确切的含义,对于相同的输入只能得出相同的输出
- 可行性：算法中描述的操作都可以通过己经实现的基本运算执行有限次来实现
- 输入：一个算法有**零个或多个**输入,这些输入取自于某个特定的对象的集合
- 输出：一个算法有**一个或多个**输出,这些输出是与输入有着某种特定关系的量
  [^2]:算法是有穷的,必须有一个解,但是程序是可以是无穷的。

### 好算法的目标

- 正确性：算法应能够正确地解决求解问题。
- 可读性：算法应具有良好的可读性,以帮助人们理解。
- 健壮性：可以应对非法数据,处理好边界条件
- 高效率与低存储量需求：效率是指算法执行的时间,存储量需求是指算法执行过程中所需要的最大存储空间,这两者都与问题的规模有关。

## <font color="red">算法的复杂度分析</font>

### 时间复杂度分析

#### 时间复杂度概念

**一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 $T$,它是该算法问题规模 $n$ 的函数,时间复杂度主要分析 $T(n)$的数量级。**
需要注意的是时间复杂度有以下三种：

- 最坏时间复杂度：在最坏情况下,算法的时间复杂度
- 平均时间复杂度：是指所有可能输入实例在等概率出现的情况下,算法的期望运行时间。
- 最好时间复杂度：在最好情况下,算法的时间复杂度。

**一般情况下考虑的都是最坏情况下的时间复杂度。**

分析时间复杂度时,需要遵循以下准则

- 加法规则：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(\max(f(n),g(n)))$
- 乘法规则：$T(n)=T_1(n){\times}T_2(n)=O(f(n)){\times}O(g(n))=O(f(n){\times}g(n))$

#### 渐进复杂度

不同$O$的意义：

- $\Theta$,读音：theta,等于的意思。
- $O$,读音：big-oh, 小于等于的意思。
- $o$,读音：small-oh,小于的意思。
- $\Omega$,读音：big omega, 大于等于的意思。
- $\omega$,读音：small omega,大于的意思。

- 常见渐进时间复杂度
  $$
  O(1)<O(\log_2n)<O(n)<O(n\text{log}_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
  $$

#### 时间复杂度的计算

> 主要有以下题型,主要使用定义法分析,实在不行代数算。其实这个地方的计算主要是看有多少循环,循环对时间复杂度的影响是最大的。

定义法求解流程：

- 单层循环：
  - 计算基本语句的执行次数$t$,如果是常数级，就记为 1，写出循环体中自变量$i$的变化过程
  - 计算最终基本语句的执行次数与$n$的关系
- 多层循环：
  - 内层循环变量不影响内层循环，直接将两个时间复杂度相乘即可
  - 外层循环变量影响内层循环
    - 写出内，外层循环中变量的变化过程
    - 从内向外依次求解
    - 使用求和公式计算执行次数

1. 单层循环

```c++
int count = 0;
for (int i = 1; i <= n; i++)
{
    count++;
}
```

第一步：`count++`是常数级执行的语句，因此，记为 1。之后循环体中自变量`i`的$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}1$
第二步：执行次数为$i$次。$i$与$n$的关系为$i\leq n$
则时间复杂度为$O(n)$

---

```c++
int count = 0;
for (int i = 1; i <= n; i*=2)
    count++;
```

第一步：`count++`是常数级执行的语句，因此，记为 1。之后循环体`i`的变化量为$\sum_{\mathrm{i~in~\{1,2.,..,2^k\}}}1$ [^3]
第二步：执行次数为$2^k$次，$2^k=n$,$k=\log_2 n$
时间复杂度为$O(\log_n)$
[^3]:因为自变量$i==n$时循环停止,因此$i==2^k$时候停止

---

```c++
int i = 0,s = 0;
while (s<n)
{
    ++i;
    s=s+i;
}
```

这题就不太好看出来,所以直接代数试,看$n=1,2,3,4,5,6,7,8,9,10...$时候运行次数,然后估出来时间复杂度。时间复杂度为$O(n^\frac{1}{2})$

---

2. 双层循环

```c++
int count = 0;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        count++;
```

外层循环变量不影响内层循环，直接将两个时间复杂度相乘，结果为时间复杂度为$O(n^2)$

[^4]: 该式的数学含义为$i$从$1$加到$n$,加$n$次

---

```c++
int count = 0;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
        count++;
```

第一步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}\sum_{\mathrm{j~in~\{1,2.,..,i\}}}$
第二步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}i$
第三步：等差数列数列求和公式$\dfrac{n(n+1)}{2}$
时间复杂度为$O(n^2)$

---

```c++
int count = 0;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j*=2)
        count++;
```

第一步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}\sum_{\mathrm{j~in~\{1,2.,..,2^k\}}}$
第二步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}\log_i$
第三步：$\log1+\log2+...+\log n=\log(n!)$
时间复杂度为$O(n\log n)$

---

```c++
int count = 0;
for (int i = 1; i <= n; i*=2)
    for (int j = 1; j <= i; j++)
        count++;
```

第一步：$\sum_{\mathrm{i~in~\{1,2.,..,2^k\}}}\sum_{\mathrm{j~in~\{1,2.,..,i\}}}$
第二步：$\sum_{\mathrm{i~in~\{1,2.,..,2^k\}}}i$
第三步：$1+2+...+2^k=2^{k+1}-1$
时间复杂度为$O(n)$

---

3. 三层循环

```c++
int count = 0;
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= i; j++)
        for (int k = 1; k <= j; k++)
            count++;
```

第一步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}\sum_{\mathrm{j~in~\{1,2.,..,i\}}}\sum_{\mathrm{k~in~\{1,2.,..,j\}}}$
第二步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}\sum_{\mathrm{j~in~\{1,2.,..,i\}}}j$
第三步：$\sum_{\mathrm{i~in~\{1,2.,..,n\}}}\dfrac{i(i+1)}{2}$
第四步：${\dfrac{1}{2}}\Big[{\big(}1^{2}+2^{2}+3^{2}+\ldots+n^{2}{\big)}+{\big(}1+2+3+\ldots+n{\big)}{\big]}={\frac{1}{2}}\Big[{\dfrac{n(n+1)(2n+1)}{6}}+{\dfrac{n(n+1)}{2}}\Big] =\dfrac{n(n+1)(n+2)}6$
时间复杂度为$O(n^3)$

---

#### Master 定理计算递归时间复杂度

![20240810161925](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240810161925.png)

- Master 定理主要用于求解递归的时间复杂度
- **Master 定理主要内容**：将一个规模为$n$的问题，通过分治得到$a$个规模为$\dfrac nb$的子问题，每次递归带来的额外计算为$f(n)$,那么我们得到以下关系式：
  $$T(n)=aT(\dfrac nb)+f(n)$$
  则可存在如下三种情况：
  1. 当 $f(n)=\mathcal{O}(n^{(\log_ba)-\epsilon})$ 其中 $\epsilon>0$ 是一个常数(相当于$\log_ba>f(n)$ ),则有$T(n)=\Theta(n^{\text{log}_ba})$
  2. 当$f(n)=\Theta(n^{\log_ba})$,则有 $T(n)=\Theta (n^{\log_ b a} \log n)$
  3. 当$f(n)=\Omega(n^{(\log_ba)+\epsilon})$其中$\epsilon>0$是一个常数(相当于$\log_ba<f(n)$),且对于一个常数$c<1$和所有足够大的$n$有$af(\dfrac nb)\leq cf(n)$ (这一条件在这里可以暂时忽略不看，但在证明时起到至关重要的作用),则有$T(n)=\Theta(f(n)).$
     根据上面的三种情况，举出以下例子：
  - $T(n)=4T(\dfrac n2)+n$,此时 $a=4,b=2,\epsilon=1$,那么$\log_ba=\log_24=2,f(n)=\mathcal{O}(n^{\log_ba-\epsilon})=\mathcal{O}(n^{2-1})$,$f(n)$ 成立，所以$T(n)=\Theta(n^{\log_ba})=\Theta(n^2)$
  - $T(n)=2T(\dfrac n2)+n$,此时 $a=2,b=2$,那么$\log_ba=\log_22=1,f(n)=\Theta(n^{\log_ba})=\Theta(n)$,$f(n)$ 成立，所以 $T(n)=\Theta(n^{\log_ba} \log n)=\Theta(n\log n).$
  - $T(n)=4T(\dfrac n2)+n^3$,此时 $a=4,b=2,\epsilon=1$,那么$\log_ba=\log_24=2,f(n)=$ $\Omega(n^{\log_ba+\epsilon})=\Omega(n^{2+1})$,对于$c=\dfrac{2}{3}$和够大的$n$,$\left(af(\dfrac nb)=4(\dfrac n2)^3=4(\dfrac{n^3}8)=\dfrac{n^3}2\right)\leq$ $\left(cf(n)=\dfrac{2n^3}3\right)$,$f(n)$ 成立，所以$T(n)=\Theta(f(n))=\Theta(n^3)$
  - $T(n)=2T(\dfrac n2)+n\log n$,此时$a=2,b=2,k=1$,那么$\log_b a=\log_2 2= 1,f(n)=\Theta(n^{\log_b a} \log^{k}n)=\Theta(n\log n),f(n)$ 成立，所以$T(n)=\Theta(n^{\log_ba}\log^{k+1}n)=\Theta(n\log^2n)$。

```c++
int fact(int n){
    if (n <= 1) return 1;
    return n * fact(n - 1);
}
```

代码由一个嵌套函数构成,一层递归其实就是一层`for`循环,那么上述代码的时间复杂度为$O(n)$

### 空间复杂度分析

#### 空间复杂度概念

算法的空间复杂度 $S(n)$ **定义为该算法除存储数据结构本身所需要的空间外,还需要的额外存储空间**,它是问题规模 $n$ 的函数。记为
$$S(n) = O(g(n))$$
**一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外,还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间**。若输入数据所占空间只取决于问题本身,和算法无关,则只需分析除输入和程序之外的额外空间。
算法原地工作是指算法所需的辅助空间为常量,即$O(1)$。

#### 空间复杂度计算

```c++
int sum = 0;
for (int i = 1; i < n; i *= 2)
    for (int j = 0; j < i; j++)
        sum++;
```

无论问题规模怎么变,算法运行所需的内存空间都是固定的常量,算法空间复杂度为$O(1)$

---

```c++

void test(int n)
{
    int flag[n];
    int i;
}
```

空间复杂度为$O(n)$

---

```c++
void test(int n)
{
    int flag[n][n];
    int i;
}
```

空间复杂度为$O(n^2)$

---

```c++
void test(int n)
{
    int flag[n][n];
    int other[n];
    int i;
}
```

空间复杂度为 $\mathrm{S(n)=O(n^2)+O(n)+O(1)=O(n^2)}$ ,由加法定理可知即$O(n^2)$

---

```c++
int fact(int n){
    if (n <= 1) return 1;
    return n * fact(n - 1);
}
```

递归代码的空间复杂度即位递归的深度,即空间复杂度为$S(n)=O(n)$

# 本章易错总结

1. 有序表是指关键字有序的线性表,仅描述元素之间的逻辑关系,因此有序表是逻辑结构
