# 数据结构的定义

## 基本概念和术语

### 数据

数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。

### 数据元素

**数据元素是数据的基本单位**，通常作为一个整体进行考虑和处理。**一个数据元素可由若干数据项组成**，**数据项是构成数据元素的不可分割的最小单位**。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。

### 数据对象

数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合$N=\{0,\pm1,\pm2,...\}$。

### 数据类型

数据类型是一个值的集合和定义在此集合上的一组操作的总称。

- 原子类型：其值不可再分的数据类型
- 结构类型：其值可以再分解为若干成分（分量）的数据类型。
- 抽象数据类型：抽象数据组织及与之相关的操作

### 数据结构

数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种**数据元素相互之间的关系称为结构(Structure)**。**数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算**。
数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。

> 需要注意的是数据结构无明确定义。

## 数据结构三要素

### <font color="red">逻辑结构</font>

逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的。**数据的逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。可以用多种存储结构实现同一种逻辑结构**。
![20231206144302](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20231206144302.png)

### <font color="red">存储结构</font>

**存储结构是指数据结构在计算机中的表示(又称映像)，也称物理结构**。它包括数据元素的表示和关系的表示。**数据的存储结构是用计算机语言实现的逻辑结构**，它依赖于计算机语言。**数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储**。

#### 顺序顺序存储

**把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中**，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。

#### 链式存储

**不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系**。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。

#### 索引存储

**在存储元素信息的同时，还建立附加的索引表**。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。

#### 散列存储

**根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储**。其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。

### 数据的运算

施加在数据上的运算包括运算的定义和实现。**运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。**

# 算法

## 算法的概念

### 定义

**算法是对特定问题求解步骤的一种描述**，它是指令的有限序列，其中的每条指令表示一个或多个操作。

### 算法的特征

- 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
- 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
- 可行性。算法中描述的操作都可以通过己经实现的基本运算执行有限次来实现。
- 输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
- 输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

### 好算法的目标

- 正确性。算法应能够正确地解决求解问题。
- 可读性。算法应具有良好的可读性，以帮助人们理解。
- 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。
- 高效率与低存储量需求。效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关。

## <font color="red">算法的复杂度分析</font>

### 时间复杂度分析

#### 时间复杂度概念

**一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记为 $T$，它是该算法问题规模 $n$ 的函数，时间复杂度主要分析 $T(n)$的数量级。**
需要注意的是时间复杂度有以下三种：

- 最坏时间复杂度：在最坏情况下，算法的时间复杂度
- 平均时间复杂度：是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。
- 最好时间复杂度：在最好情况下，算法的时间复杂度。

**一般情况下考虑的都是最坏情况下的时间复杂度。**

分析时间复杂度时，需要遵循以下准则

- 加法规则：$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(\max(f(n),g(n)))$
- 乘法规则：$T(n)=T_1(n){\times}T_2(n)=O(f(n)){\times}O(g(n))=O(f(n){\times}g(n))$

- 常见渐进时间复杂度
  $$
  O(1)<O(\log_2n)<O(n)<O(n\text{log}_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)
  $$

#### 时间复杂度的计算

> 主要有以下题型，会分析即可，实在不行代数算。其实这个地方的计算主要是看有多少循环，循环对时间复杂度的影响是最大的。

- 一层循环
- 解题思路：
  - 列出循环次数 `T` 和每轮循环 `i` 的变化值
  - 找到 `T` 与 `i` 的关系
  - 确定循环终止条件
  - 联立两式解方程

```c++
i = n * n;
while (i != 1)
    i /= 2;
```

| $t $ | $ 0$  |      $ 1 $      |      $ 2 $      |      $ 3 $      | ... |
| ---- | :---: | :-------------: | :-------------: | :-------------: | :-: |
| $i$  | $n^2$ | $\frac{n^2}{2}$ | $\frac{n^2}{4}$ | $\frac{n^2}{8}$ | ... |

可以看到循环次数与$n$的关系是$O(\log_2 n)$

```c++
x = 0;
while (n >= (x + l) * (x + l))
    x = x + l;
```

令`l=0`,那么执行次数与$n$的关系是

| $x$ | $1$ | $2$ | $3$ | $4$  | $5$  | $...$ | $n$   |
| :-: | :-: | :-: | :-: | ---- | ---- | ----- | ----- |
| $k$ | $1$ | $4$ | $9$ | $16$ | $25$ |       | $k^2$ |

可以看到循环次数$n$的关系是$O(\sqrt{n})$

```c++
int func(int n) {
    int i=0, sum=0;
    while (sum < n) sum += ++i;
    return i;
}
```

|  $i$  | $1$ | $2$ | $3$ | $4$  | $5$  | $...$ | $k$               |
| :---: | :-: | :-: | :-: | ---- | ---- | ----- | ----------------- |
| $sum$ | $1$ | $3$ | $6$ | $10$ | $15$ |       | $k * (k + 1) / 2$ |

执行次数$k$与$n$的关系应该是$\sqrt{2 \times n}$,因此时间复杂度应该为$O(\sqrt{n})$

---

- 二层循环
- 解题思路：

  - 列出外层循环中 `i` 的变化值
  - 列出内层语句的执行次数
  - 求和

```c++
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= 2 * i; j++)
        m++;
```

|       $i$        | $1$ | $2 $ | $3$  | $ 4$ | $ 5 $ | ... | $ n $ |
| :--------------: | :-: | :--: | :--: | :--: | :---: | :-: | :---: |
| 内层语句执行次数 | $1$ | $1$  | $1$  | ...  |  ...  | ... |  ...  |
|                  | $2$ | $2$  | $2$  | ...  |  ...  | ... |  ...  |
|                  |     | $3$  | $3$  | ...  |  ...  | ... |  ...  |
|                  |     | $4$  | $4$  | ...  |  ...  | ... |  ...  |
|                  |     |      | $ 5$ | ...  |  ...  | ... |  ...  |
|                  |     |      | $6 $ | ...  |  ...  | ... | $2n$  |

等差数列求和$\frac{n(2+2n)}{2}$ ,时间复杂度为$T=O(n^2)$

```c++
count = 0;
for (k = 1; k <= n; k *= 2)
    for (j = 1; j <= n; j++)
        count++;
```

|      $ i $       |  1  | $2^1$ | $2^2$ | $2^3$ | $2^4$ | ... | $2^{(n-1)}$ |
| :--------------: | :-: | :---: | :---: | :---: | :---: | :-: | :---------: |
| 内层语句执行次数 | $1$ |  $1$  |  $1$  |  $1$  |  $1$  | ... |     $1$     |
|                  | $2$ |  $2$  |  $2$  |  $2$  |  $2$  | ... |     $2$     |
|                  | $3$ |  $3$  |  $3$  |  $3$  |  $3$  | ... |     $3$     |
|                  | $4$ |  $4$  |  $4$  |  $4$  |  $4$  | ... |     $4$     |
|                  | ... |  ...  |  ...  |  ...  |  ...  | ... |     ...     |
|                  | $n$ |  $n$  |  $n$  |  $n$  |  $n$  | ... |     $n$     |

求和可得$n \times \log_2(n-1)$ ,时间复杂度为$T=O(n\log n)$

```c++
for (i = n - 1; i > 1; i--)
    for (j = 1; j < i; j++)
        if (A[j] > A[j + 1])
            A[j], A[j + 1] 交换;
```

|       $ i$       | $n-1$ | $n-2$ | $n-3$ | $n-4$  |  $n-5$  | ... | $1$ |
| :--------------: | :---: | :---: | :---: | :----: | :-----: | :-: | :-: |
| 内层语句执行次数 |  $1$  |  $1$  |  $1$  |  $1$   |   $1$   | ... | $1$ |
|                  |  $2$  |  $2$  |  $2$  |  $2$   |   ...   | ... |     |
|                  |  $3$  |  $3$  |  $3$  |  ...   | $ n-4 $ | ... |     |
|                  | $4 $  | $ 4 $ |  ...  | $ n-5$ |         | ... |     |
|                  |  $5$  |  ...  | $n-4$ |        |         | ... |     |
|                  |  ...  | $n-3$ |       |        |         | ... |     |
|                  | $n-2$ |       |       |        |         | ... |     |

求和可得 $\frac{n \times (n-2+1)}{2}$ ,时间复杂度为$T=O(n^2)$

```c++
int sum = 0;
for (int i = 1; i < n; i *= 2)
    for (int j = 0; j < i; j++)
        sum++;
```

|       $i $       |  1  |  2  | $2^2$ | $2^3$ | $2^4$ | ... | $2^{n-1}$ |
| :--------------: | :-: | :-: | :---: | :---: | :---: | :-: | :-------: |
| 内层语句执行次数 | $1$ | $1$ |  $1$  |  $1$  |  $1$  | ... |    $1$    |
|                  |     | $2$ |  $2$  |  $2$  |  $2$  | ... |    $2$    |
|                  |     |     |  $3$  |  $3$  |  $3$  | ... |    $3$    |
|                  |     |     |  $4$  |  $4$  |  $4$  | ... |    $4$    |
|                  |     |     |       |  $5$  |  $5$  | ... |    $5$    |
|                  |     |     |       |  ...  |  ...  | ... |    ...    |
|                  |     |     |       |  $8$  | $16$  | ... | $2^{n-1}$ |

求和可得$\frac{1(1-2^{log_2(n-1)})}{1-2}=n-1$,时间复杂度为$O(n)$

```c++
int sum = 0;
for(int i=1; i<=n; i++)
    sum += i;
for(int i=1; i<=n; i++)
    for(int j=1; j<=n; i++)
        sum += i;
```

代码由两段`for`循环构成，因此根据加法定理可以知道，时间复杂度为$T(n)=n^2+n$,根据乘法定理可得时间复杂度为$O(n^2)$

```c++
int count = 0;
for (int i = 0; i <= n; i++)
    for (int j = 1; j <= i; j *= 2)
        count++;
```

| $i$ | $1$ | $2$ | $3$ | $4$ | $5$ | $...$ |   $n$    |
| :-: | :-: | :-: | :-: | :-: | :-: | :---: | :------: |
| $j$ | $1$ | $1$ | $1$ | $1$ | $1$ | $...$ | $log_2n$ |
|     |     | $2$ | $2$ | $2$ | $2$ | $...$ |          |
|     |     |     |     | $4$ | $4$ | $...$ |          |

求和可得$n \times \log n$,时间复杂度为$n \log n$

---

- 三层循环

```c++
for (int i = 0; i <= n; i++)
    for (int j = 0; j <= i; j++)
        for (int k = 0; k < j; k++)
```

- 方法一:抽象为计算三维体积
  ![20231220215426](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20231220215426.png)
- 方法二:公式法
  $
  \begin{aligned}
  & \sum_{i=0}^{n}\sum_{j=0}^{i}\sum_{k=0}^{j-1} \\
  = &\sum_{i=0}^{n}\sum_{j=0}^{i}(j-1-0+1) \\
  = & \sum_{i=0}^{n}\sum_{j=0}^{i}j \\
  = & \sum_{i=0}^{n}\frac{i(i+1)}{2} \\
  = & \frac{1}{2}\sum_{i=0}^{n}(i^{2}+i) \\
  = & \frac{1}{2}\sum_{i=0}^{n}i^{2}+\frac{1}{2}\sum_{i=0}^{n}i \\
  = & O(n^{3})
  \end{aligned}
  $

---

- 递归

```c++
int fact(int n){
    if (n <= 1) return 1;
    return n * fact(n - 1);
}
```

代码由一个嵌套函数构成,一层递归其实就是一层`for`循环，那么上述代码的时间复杂度为$O(n)$

---

### 空间复杂度分析

#### 空间复杂度概念

算法的空间复杂度 $S(n)$ 定义为该算法所耗费的存储空间，它是问题规模 $n$ 的函数。记为
$$S(n) = O(g(n))$$
**一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间**。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。
算法原地工作是指算法所需的辅助空间为常量，即$O(1)$。

#### 空间复杂度计算

```c++
    int sum = 0;
    for (int i = 1; i < n; i *= 2)
    for (int j = 0; j < i; j++)
    sum++;
```

无论问题规模怎么变，算法运行所需的内存空间都是固定的常量，算法空间复杂度为$O(1)$

---

```c++

void test(int n)
{
int flag[n];
int i;
}
```

空间复杂度为$O(n)$

---

```c++
void test(int n)
{
    int flag[n][n];
    int i;
}
```

空间复杂度为$O(n^2)$

---

```c++
void test(int n)
{
    int flag[n][n];
    int other[n];
    int i;
}
```

空间复杂度为 $\mathrm{S(n)=O(n^2)+O(n)+O(1)=O(n^2)}$ ,由加法定理可知即$O(n^2)$

---

```c++
int fact(int n){
    if (n <= 1) return 1;
    return n * fact(n - 1);
}
```

递归代码的空间复杂度即位递归的深度，即空间复杂度为$S(n)=O(n)$
