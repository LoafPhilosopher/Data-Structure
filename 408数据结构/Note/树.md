# 树的基本概念

## 树的定义

树是$n(n \geq 0)$个结点的有限集.当$n=0$时.称为空树.在任意一棵非空树中应满足:

- 有且仅有一个特定的称为根的结点(考研中的树被认为是有根树,而不是无根树)
- 当 $n>1$ 时,其余结点可分为 $m(m>0)$ 个互不相交的有限集$T_1,T_2,\cdots,T_m$,其中每个集合本身又是一棵树,并且称为根的子树.

显然,树的定义是递归的,即在树的定义中又用到了其自身,树是一种递归的数据结构.

## 树的基本术语

### 树中结点关系

- 父亲(parent node):对于除根以外的每个结点,定义为从该结点到根路径上的第二个结点.根结点没有父结点.
- 祖先(ancestor):一个结点到根结点的路径上,除了它本身外的结点.  
  根结点的祖先集合为空.
- 子结点(child node):如果 $u$ 是 $v$ 的父亲,那么 $v$ 是 $u$ 的子结点.子结点的顺序一般不加以区分,二叉树是一个例外.
- 兄弟(sibling):同一个父亲的多个子结点互为兄弟.
- 后代(descendant):子结点和子结点的后代.
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417133409.png" width = 80%/></div>

### 树中基本术语

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417141050.png" width = 80%/></div>

- 子树:删掉与父亲相连的边后,该结点所在的子图.如上图中,与 C 结点颜色一样的点,是 C 结点的子图.
- **结点的度和树的度:一个结点含有的孩子的个数称为该结点的度,树中结点的最大度数称为树的度**.该树中 A 结点的度是 3,B 结点的度是 2,该树的度是 3.
- 分支结点:度大于 0 的结点称为分支结点(又称非终端结点);在分支结点中,每个结点的分支数就是该结点的度.上图中,ABCDGL 为分支结点.
- 叶子结点:没有子结点的结点,如图中,EFGKHIMN 结点
- 结点的深度和层次:结点的层次从树根开始定义,根结点为第 1 层,它的孩子为第 2 层,以此类推.结点的深度就是结点所在的层次
- 树的高度(或深度):树中结点的最大层数
- 结点的高度:以该结点为根的子树的高度
- 有序树和无序树:树中结点的各子树从左到右是有次序的,不能互换,称该树为有序树,否则称为无序树.
- 路径和路径长度:树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的,而路径长度是路径上所经过的边的个数.

## 树的性质

1. 树中的结点数等于所有结点的度数加 1
   总结点数 $n_0+n_1+n_2+\ldots+n_m$
   总结点数$=1+1n_1+2n_2+\cdots+mn_m$(度为$m$ 的结点引出$m$条分支)
2. 度为$m$的树中第$i$层上至多有$m^{i-1}$个结点.
3. 高度为$h$的$m$叉树至多有$\dfrac{(m^h-1)}{(m-1)}$个结点.
4. 具有$n$个结点的$m$叉树(或度为$m$)的最小高度为$ceil(log_m(n(m-1)+1))$,`ceil`向上取整
5. 度为$m$、具有$n$个结点的树的最大高度$h$为$n-m+1$

上述公式的推导:

1. 所有结点的出度记录了他们的结点数.那么加上根结点就相当与整个树的结点数
2. 已知树的度为 $m$ ,那么第二层最多有 $m$ 个结点,第三层最多有$m^2$个结点,第四层最多有 $m^3$ 个结点,那么可以观察出,第 $i$ 层最多有$m^{i-1}$个结点
3. 由第二个性质可知,$m$ 叉树每一层如果是 $m^{i-1}$ 个结点的话,总计整个树最多有 $\dfrac{(m^h-1)}{(m-1)}$ 个结点
4. 为使树的高度最小,在前 $h-1$ 层中,每层的结点数都要达到最大,前 $h-1$ 层最多有 $\dfrac{(m^{h-1}-1)}{(m-1)}$ 个结点,前$h$层最多有 $\dfrac{(m^h-1)}{(m-1)}$ 个结点.因此 $\dfrac{(m^{h-1}-1)}{(m-1)} <n \leq \dfrac{(m^h-1)}{(m-1)}$,即 $h-1<\log_m(n(m-1)+1)\leqslant h$ ,解得 $h_{\min}=\left\lceil\log_m(n(m-1)+1)\right\rceil$
5. 由于树的度为 $m$, 因此至少有一个结点有 $m$ 个孩,它们处于同一层.为使树的高度最大,其他层可仅有一个结点,因此最大高度(层数)为 $n-m+1$.由此,也可逆推出高度为$h$、度为$m$ 的树至少有 $h+m-1$ 个结点

## 树的遍历

### 先根遍历

### 后根遍历

# 二叉树的概念

## 二叉树的定义

二叉树是一种特殊的树形结构,其特点是**每个结点至多只有两棵子树(即二叉树中不存在度大于 2 的结点)**,并且二叉树的**子树有左右之分**,其**次序不能任意颠倒**.
与树相似,二叉树也以递归的形式定义.二叉树是$n(n≥0)$个结点的有限集合:

- 或者为空二叉树,即 $n=0$.
- 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。
  ![20240417150027](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417150027.png)

## m 叉树与度为 m 的树和度为 m 的有序树的区别

- 高度为$h$的$m$叉树和高度为$h$度为$m$的树的区别:
  - 度为 m 的树中,必须至少有一个结点有 m 个孩子结点.
  - m 叉树中可以没有一个结点的孩子数等于 m,甚至可以是一棵空树.
- m 叉树和度为 m 的有序树的区别:
  - 度为 m 的树至少有 m+1 个结点,m 叉树可以为空
  - 度为 m 的有序树的孩子结点的左右次序是相对而言的,若某个结点只有一个孩子,则这个孩子就不存在左右这个概念.m 叉树无论有没有 m 个孩子,均需要区分左右孩子结点

## 二叉树的性质

1. 树中的结点数等于所有结点的度数加 1.
   总结点数$=n_0+n_1+n_2$
   总结点数$=1+1n_1+2n_2$(度为$m$ 的结点引出$m$条分支)
2. 非空二叉树上第$k$层上至多有$2^{k-1}$个结点.
3. 高度为$h$的二叉树至多有$2^h-1$个结点.
4. 具有$n$个结点的完全二叉树高度为 $ceil(\log_2(n+1))$ 或 $\mathrm{floor}(\log_2(n))+1$.
5. $n_0=n_2+1$.
6. $n$ 个结点可构造出 $\dfrac{C_{2n}^n}{n+1}$ 个不同的二叉树

上述公式的推导:

1. 所有结点的出度记录了他们的结点数.那么加上根结点就相当与整个树的结点数.
2. 已知树的为非空二叉树,那么第二层最多有 2 个结点,第三层最多有$2^2$个结点,第四层最多有 $2^3$ 个结点,那么可以观察出,第 $k$ 层最多有$2^{k-1}$个结点
3. 由第二个性质可知,二叉树每一层如果是 $2^{i-1}$ 个结点的话,总计整个树最多有 $\dfrac{(2^h-1)}{(2-1)}=2^h-1$ 个结点
4. 为使树的高度最小,在前 $h-1$ 层中,每层的结点数都要达到最大,前 $h-1$ 层最多有 $\dfrac{(2^{h-1}-1)}{(2-1)}$ 个结点,前$h$层最多有 $\dfrac{(2^h-1)}{(2-1)}$ 个结点.因此 $\dfrac{(2^{h-1}-1)}{(2-1)} <n \leq \dfrac{(2^h-1)}{(2-1)}$,即 $h-1<\log_2(n+1)\leqslant h$ ,解得 $h_{\min}=\left\lceil\log_2(n+1)\right\rceil$
5. 由第一条可推导出

## 特殊的二叉树

### 满二叉树

![20240417154108](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417154108.png)
所有叶结点的深度均相同,且所有非叶节点的子节点数量均为 2 的二叉树称为完美二叉树.
**满二叉树的性质**:

1. 高为$h$的满二叉树上一共有$2^h-1$个结点
2. 高为$h$的满二叉树上,每层都有$2^{h-1}$个结点
3. 高为$h$的满二叉树上,所有的叶子结点都在最后一层
4. 高为$h$的满二叉树上,除叶子结点外,每个结点的度都为 2
5. 高为$h$的满二叉树上,对每个结点从上到下,从左到右进行编号(从 $1$ 开始),对于任意编号 $i$,若有双亲,则其双亲结点的编号一定是 $floor(i/2)$, 若有孩子结点,则左孩子编号为 $2i$,右孩子编号为 $2i+1$.

### 完全二叉树

![20240417154136](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417154136.png)
只有最下面两层结点的度数可以小于 2,且最下面一层的结点都集中在该层最左边的连续位置上
**完全二叉树的性质**:

1. **高为 $h$,有 $n$ 个结点的完全二叉树上,编号与满二叉树的一一对应**
2. 高为 $h$,有 $n$ 个结点的完全二叉树上,若结点编号$i>floor(n/2)$,则该结点一定是叶子结点,否则是非叶子结点
3. 高为 $h$,有 $n$ 个结点的完全二叉树上,**叶子结点只会处于最后一层和倒数第二层**
4. 高为 $h$,有 $n$ 个结点的完全二叉树上,**只可能存在一个结点度为 1 并且它肯定只有左孩子没有右孩子**
5. 高为 $h$,有 $n$ 个结点的完全二叉树上,若 n 为奇数则所有结点度都为 2,若为偶数,则有一个结点度为 1。(叶子结点除外)
6. 具有 $n$ 个 $(n>0)$ 结点的完全二叉树的高度为 $ceil(\log_2(n+1))$或$floor(\log_2n)+1$.
<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417160429.png" width = 40%/></div>

<a id="section1"></a>

### [二叉排序树](#section2)

左子树上所有结点的关键字均小于根结点的关键字;右子树上所有结点的关键字均大于根结点的关键字;左子树和右子树又各是一棵二叉排序树.

<a id="section3"></a>

### [平衡二叉树](#section4)

树中任意一个结点的左子树和右子树的高度之差的绝对值不超过 1.

### 正则二叉树

树中每个分支结点都有 2 个孩子,即树中只有度为 0 或 2 的结点

## 二叉树的存储结构

### 顺序存储

二叉树的顺序存储是指用一组连续的存储单元依次自上而下,自左至右存储完全二叉树上的结点元素,即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中.
但对于一般的二叉树,为了让数组下标能反映二叉树中结点之间的逻辑关系,只能添加一些并不在在的空结点,让其每个结点与完全二叉树上的结点相对照,再存储到一维数组的相应分量中.如下图所示:

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418114858.png" width = 80%/></div>

二叉树顺序存储的优点是结点间关系直接体现在数组下标中,结点内部无需使用额外的空间去存储孩子或双亲结点的指针,可以直接根据数组下标找到任意结点的孩子和双亲结点.
顺序存储方式缺点很明显,对一般二叉树,特别是稀疏二叉树,需补充大量占位的结点,导致存储空间浪费。

### 链式存储

二叉树的链式存储解决了顺序存储在某些情况下空间利用率低的缺点.其 c 语言描述为:

```c++
typedef struct BiTNode
{
    ElemType data;//数据域
    struct BiTNode *lchild, *rchild;//左右孩子指针
}BiTNode,*BiTree;
```

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418115608.png" width = 100%/></div>

## 二叉树的遍历

### 树上 DFS

在树上 DFS 是这样的一个过程:先访问根节点,然后分别访问根节点每个儿子的子树.

#### 先序遍历

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418120417.png" width = 80%/></div>

```c++
void preorder(BiTree* root) {
  if (root) {
    cout << root->key << " "; // 根
    preorder(root->left); //左
    preorder(root->right);//右
  }
}
```

#### 中序遍历

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418120619.png" width = 80%/></div>

```c++
void inorder(BiTree* root) {
  if (root) {
    inorder(root->left);
    cout << root->key << " ";
    inorder(root->right);
  }
}
```

在遍历过程中:

- 若该结点是其双亲结点的左孩子,则它的双亲结点此时还没有被访问且在栈中.
- 当访问到任意结点时,都代表以该结点为根的左子树已经遍历完成并且都退出了栈.
- 若该结点是其双亲结点的右孩子,那么此时其双亲结点已经被访问过并且出栈了

#### 后序遍历

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418120713.png" width = 80%/></div>

```c++
void postorder(BiTree* root) {
  if (root) {
    postorder(root->left);
    postorder(root->right);
    cout << root->key << " ";
  }
}
```

在遍历过程中:

- 若该结点是其双亲结点的左孩子,此时其双亲结点都没有被访问到并且还在栈中.而且该结点的所有祖先结点也保存在栈中
- 当访问到任意结点时,都代表以该结点为根的子树已经全部遍历完成并且都退出了栈,不会再访问到
- 若该结点是其双亲结点的右孩子,此时其双亲结点都没有被访问到并且还在栈中.而且该结点的所有祖先结点也保存在栈中

### 树上 BFS

从树根开始,严格按照层次来访问节点.

#### 层次遍历

树层序遍历是指按照从根节点到叶子节点的层次关系,一层一层的横向遍历各个节点。根据 BFS 的定义可以知道,BFS 所得到的遍历顺序就是一种层序遍历。但层序遍历要求将不同的层次区分开来,所以其结果通常以二维数组的形式表示。

例如,下图的树的层序遍历的结果是 `[[1], [2, 3, 4], [5, 6]]`(每一层从左向右)。

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418121903.png" width = 40%/></div>

```c++
vector<vector<int>> levelOrder(Node *root)
{
    if (!root)
    {
        return {};
    }
    vector<vector<int>> res;
    queue<Node *> q;
    q.push(root);
    while (!q.empty())
    {
        int currentLevelSize = q.size(); // 当前层的节点个数
        res.push_back(vector<int>());
        for (int i = 0; i < currentLevelSize; ++i)
        {
            Node *cur = q.front();
            q.pop();
            res.back().push_back(cur->val);
            for (Node *child : cur->children)
            { // 把子节点都加入
                q.push(child);
            }
        }
    }
    return res;
}
```

### 由遍历序列构造二叉树

已知中序遍历序列和另外一个序列可以求出树的结构

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418120807.png" width = 80%/></div>

1.  前序的第一个是 `root`,后序的最后一个是 `root`
2.  先确定根节点,然后根据中序遍历,在根左边的为左子树,根右边的为右子树
3.  对于每一个子树可以看成一个全新的树,仍然遵循上面的规律

### 线索二叉树

- 定义:一个二叉树通过如下的方法"穿起来":所有原本为空的右子节点指针改为指向该节点在中序序列中的后继,所有原本为空的左子节点指针改为指向该节点的中序序列的前驱.
- 作用:线索二叉树能线性地遍历二叉树,从而比递归的中序遍历更快.使用线索二叉树也能够方便的找到一个节点的父节点.
- 线索二叉树的存储结构:
<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418151020.png" width = 80%/></div>
其中标志域的含义如下:

$$
\begin{aligned}&\text{ltag}=\begin{cases}0,&\text{lchild域指示结点的左孩子}\\1,&\text{lchild域指示结点的前驱}\end{cases}\\&\text{rtag}=\begin{cases}0,&\text{rchild域指示结点的右孩子}\\1,&\text{rchild域指示结点的后继}\end{cases}\end{aligned}
$$

线索为 1 时,指针域是前驱或后继结点,为 0 时,指针域是孩子结点.
代码表示:

```c++
typedef struct ThreadNode
{
    int data;// 数据元素
    struct ThreadNode *lchild, *rchild;//左,右孩子指针
    int lTag, rTag;//左右线索标记
}ThreadNode,*ThreadTree;
```

#### 中序线索二叉树

![20240418152344](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418152344.png)

##### 中序线索二叉树的存储

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418152422.png" width = 80%/></div>

##### 中序线索化

```c++
void setThread(ThreadTree &root, ThreadTree &pre)
{
    if (!root->lchild) // 当前结点的左子树为空
    {
        root->lchild = pre; // 建立当前结点的前驱结点
        root->lTag = 1;
    }
    else
        root->lTag = 0;
    if (pre && !pre->rchild) // 前驱结点非空且其右子树为空
    {
        pre->rchild = root; // 建立前驱结点的后继线索
        pre->rTag = 1;
    }
    else
        root->lTag = 0;
    pre = root; // 标记当前结点成为刚刚访问过的结点
}
void InThread(ThreadTree &root, ThreadTree &pre)
{
    if (!root) // 空树直接返回
        return;
    InThread(root->lchild, pre); // 递归线索化左子树
    setThread(root, pre);        // 访问根结点
    InThread(root->rchild, pre); // 递归,线索化右子树
}
void CreateInThread(ThreadTree T)
{
    ThreadTree pre = NULL;
    if (T)
    {
        InThread(T, pre);   // 非空二叉树,线索化
        pre->rchild = NULL; // 线索化二叉树
        pre->rTag = 1;      // 处理遍历的最后一个结点
    }
}
```

##### 中序线索二叉树的遍历

- 中序遍历的第一个结点与最后一个结点
- 找到结点的后继
- 找到结点的前驱
- 中序遍历中序线索二叉树

#### 先序线索二叉树

![20240418152640](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418152640.png)

##### 先序线索二叉树的存储

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418152844.png" width = 80%/></div>

##### 先序线索化

```c++
void preThread(ThreadTree &root, ThreadTree &pre)
{
    if (!root) // 空树直接返回
        return;
    setThread(root, pre);        // 访问根结点
    preThread(root->lchild, pre); // 递归线索化左子树
    preThread(root->rchild, pre); // 递归,线索化右子树
}
```

##### 先序线索二叉树的遍历

- 先序遍历的第一个结点
- 先序遍历中结点的后继
- 先序遍历先序线索二叉树

#### 后序线索二叉树

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418152945.png" width = 80%/></div>

##### 后序线索二叉树的存储

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418153535.png" width = 80%/></div>

##### 后序线索化

```c++
void postThread(ThreadTree &root, ThreadTree &pre)
{
    if (!root) // 空树直接返回
        return;
    postThread(root->lchild, pre); // 递归线索化左子树
    postThread(root->rchild, pre); // 递归,线索化右子树
    setThread(root, pre);        // 访问根结点
}
```

##### 后序线索二叉树的遍历

- 后序遍历的第一个结点
- 后序遍历的后继结点
- 后序遍历后序线索二叉树

#### 三种线索二叉树的对比

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240418161534.png" width = 90%/></div>

# 森林的基本概念

## 森林的定义

森林是$m$课互不相交的树的集合

## 树,二叉树,森林的转换

## 森林的遍历

# 树的应用

## 哈夫曼树

## 并查集

## 树型查找

<a id="section2"></a>

### [二叉排序树](#section1)

<a id="section4"></a>

### [平衡二叉树](#section3)

### 红黑树

### B 树与 B^+^数

# 易错总结

- 度为 m 的树,某一层不一定只有 m 个点,如下图该树的度为 3,但是在第三层有 5 个点:
  ![20240417141050](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240417141050.png)
