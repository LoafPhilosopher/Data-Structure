# 图的基本概念

## 图的定义

- 图的定义: 图 (graph) 是一个二元组 $G=(V(G), E(G))$.其中 $V(G)$ 是非空集,称为 点集(vertex set),对于 $V$ 中的每个元素,我们称其为 顶点 (vertex)或节点 (node),简称点; $E(G)$ 为 $V(G)$ 各结点之间边的集合,称为边集(edge set).常用 $G=(V,E)$ 表示图.
- 有向图与无向图
  - 有向图的定义:若$E$是有向边(也称弧)的有限集合,则图$G$为有向图.弧是顶点的有序对,记为$<v,w>$.其中$v,w$ 是顶点,$v$称为弧尾,$w$称为弧头,$<v,w>$称为从$v$到$w$ 的弧,也称$v$邻接到$w$.
  - 无向图的定义:若 $E$ 是无向边(简称边)的有限集合,则图 $G$ 为无向图.边是顶点的无序对,记为 $(v,w)$ 或 $(w,v)$.可以说 $w$ 和 $v$ 互为邻接点.边$(v,w)$依附于$w$ 和 $v$,或称边 $(v,w)$ 和 $v,w$ 相关联.
- 简单图,多重图

  - 简单图(simple graph):若一个图中没有顶点到自身的环和重复的边,它被称为简单图
  - 多重图:如果一张图中有自环或重边,则称它为多重图(multigraph)
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503224023.png" width = 20%/></div>

- 完全图与竞赛图:

  - 完全图(无向图):设 $G$ 为一个有 $n$ 个节点的无向简单图,若 $G$ 中每个顶点都与其余 $n-1$ 个顶点有边相连,则称 $G$ 为 n 阶无向完全图,简称为 $n$ 阶完全图,记做$K_n$,边与点的关系是$\dfrac{n*(n-1)}{2}$
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503221330.png" width = 20%/></div>

  - 完全图(有向图):设 $G$ 为一个有 $n$ 个节点的有向简单图,若 $G$ 中每个顶点都有连到其余 $n-1$ 个顶点的边,且都有这些节点连向它的边,则称 $G$ 为 $n$ 阶有向完全图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503221358.png" width = 20%/></div>

  - 竞赛图:基于 $n$ 阶无向完全图,给每条边任意确定一个方向形成的图称为 $n$ 阶竞赛图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503221615.png" width = 20%/></div>

- 子图:设$G=<V,E>,G'=<V',E'>$ 为两个图(同为无向图或有向图),如果$V' \subseteq V$且$E'\subseteq E$,则称图 $G'$为图$G$的子图,$G$称为图$G'$的母图,记作$G'\subseteq G$

  - 子图有可能和自己一模一样,但是真子图不可能一模一样
  - 如果$V'=V,$则称$G'$为$G$的生成子图(点数一样但是边数不一样)
  - 如果$V'\subset V$或$E' \subset E$,则称$G'$为$G$的真子图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503222126.png" width = 70%/></div>

- 稠密图,稀疏图:
  - 稠密图:若一张图的边数远小于其点数的平方,那么它是一张稀疏图 (sparse graph)
  - 若一张图的边数接近其点数的平方,那么它是一张稠密图 (dense graph)
  - 这两个概念并没有严格的定义,一般用于讨论时间复杂度为 $O(|V|^2)$ 的算法与 $O(|E|)$ 的算法的效率差异(在稠密图上这两种算法效率相当,而在稀疏图上 $O(|E|)$ 的算法效率明显更高)
- <font color="red">连通,连通图,连通分量</font>
  - 在无向图中,若从顶点$v$到顶点$w$有路径存在,则称$v$和$w$是连通的.若图$G$中任意两个顶点都是连通的,则称图$G$为连通图,否则称为非连通图.无向图中的极大连通子图称为连通分量.
- 生成树,生成森林:
  - 生成树:(针对无向图):连通图的生成树是包含图中全部顶点的一个极小连通子图.若图中的顶点数为$n$,则它的生成树有$n-1$条边,生成树不一定唯一.
    ![20240503230757](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503230757.png)
  - 生成森林:非连通图中,连通分量的生成树构成了非连通图的生成森林

> 概念辨析:极大连通子图,极小连通子图,连通分量,生成树,生成森林
>
> <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504125057.png" width = 70%/></div>
> 如图:c是一个非连通图,其由a和b两个连通图组成,对于c来说,a和b是它的两个连通分量,a和b分别是两棵生成树,共同组成了生成森林.

## 图的基本术语

- 顶点的度,出度和入度:
  - 顶点的度:图中以该顶点为一个端点的边的数目
  - 无向图中顶点$v$的度是指依附于该顶点的边的条数,记为 $TD(v)$.具有$n$个顶点,$e$条边的无向图中,所有顶点的度总和是边数的二倍,即 $\sum_{i=1}^nTD(v_i)=2e$
  - 有向图中顶点$v$的度分为入度和出度.入度是以顶点 v 为终点的有向边的条数记为$ID(v)$
  - 出度是以顶点$v$为起点的有向边的数目,记为 $OD(v)$.具有$n$个顶点,$e$条边的有向图中,全部顶点的入度之和与出度之和相等,等于边数.即$\sum_{i=1}^n ID(v_i)=\sum_{i=1}^n OD(v_i)=e$
- 路径和路径长度,简单路径:
  - 路径:在图中,顶点 $\mathrm{V_p}$ 到顶点 $\mathrm{V_q}$ 之间的顶点序列 $\mathrm{V_p},\mathrm{V_a},\mathrm{V_b}...\mathrm{V_q}$
  - 路径长度:路径上边的数目,若该路径最短则称之为距离
  - 简单路径:序列中顶点不重复出现的路径,而且自身不存在环
- 边的权,网络(带权图):
  - 权:图中边具有与之相关的数值,称之为权重,权重可以表示从一个顶点到另一个顶点的距离、花费的代价等
  - 这种带权图也叫做网络
- 回路(环):第一个顶点和最后一个顶点相同的路径.注意:若无向图有 $n$ 个顶点,并且有大于 $n-1$ 条边,则此图一定有环
- <font color="red">强连通,强连通图,强连通分量</font>:
  - 强连通:有向图中,看从顶点 $v$ 到顺点 $w$ 和顶点 $w$ 到顶点 $V$ 之间都有路径,则称 $v$ 和 $w$ 是强连通的
  - 强连通图:有向图 $G$ 中任意两个顶点都是强连通的
  - 强连通分量:有向图中的极大强连通子图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503231457.png" width = 80%/></div>

# 图的存储和操作

## <font color="red">图的存储</font>

### 邻接矩阵

所谓邻接矩阵存储,是指用一个一维数组存储图中顶点的信息,用一个二维数组存储图中边的信息(即各顶点之间的邻接关系),存储顶点之间邻接关系的二维数组称为邻接矩阵.
顶点数为$n$ 的图 $G=(V,E)$的邻接矩阵 $A$ 是$n\times n$ 的,将$G$ 的顶点编号为$v_1,v_2,\cdots,v_n$, 则

$$
  A[i][j]=\begin{cases}1,&(v_i,v_j)\text{或}\langle v_i,v_j\rangle\text{是}E(G)\text{中的边}\\0或\infty,&(v_i,v_j)\text{或}\langle v_i,v_j\rangle\text{不是}E(G)\text{中的边}\end{cases}
$$

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504131630.png" width = 80%/></div>

```c++{.line-numbers}
typedef char VertexType; // 顶点信息对应的数据类型
typedef int EdgeType;    // 边信息对应的数据类型
typedef struct
{
    int verNum;                     // 顶点数
    int edgeNum;                    // 边数
    VerType vertex[verNum];         // 顶点信息(一维数组)
    EdgeType edges[verNum][verNum]; // 边信息(二维数组)
}MGraph;
```

### 邻接表

**图的邻接表存储方式是指对具有 $n$ 个顶点的图,建立 $n$ 条对应的单链表**,这些单链表称为**边表**.每个单链表的第一个结点称为头结点,存放顶点相关的信息.每个单链表中除了头结点外的其他结点,称为边结点,存放以头结点为起点的边的信息.
将 $n$ 个单链表的头结点存放在一个一维数组中,这个一维数组称为**顶点表**.单链表的头结点, 也称为顶点表结点.

![20240504143850](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504143850.png)
顶点表结点由两个域组成:顶点域(data)存储顶点 $v_i$ 的相关信息,边表头指针域 (firstarc)指向第一条边的边表结点.边表结点至少由两个域组成:邻接点域(adivex)在储与头结点顶点,邻接的顶点编号,指针域 (nextarc)指向下一条边的边表结点.
![20240504144339](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504144339.png)

```c++{.line-numbers}
typedef struct edgeNode // 边结点
{
    int adjVex;               // 与对应头结点邻接的顶点编号
    struct edgeNode *nextArc; // 指向下一个边结点的指针
    infoType info;            // 可有可无,对于带权图可存储边的权值
} edgeNode;
typedef struct // 头结点
{
    VerType data;       // 顶点信息
    edgeNode *firstArc; // 指向第一个邻接点的指针
} VNode;
typedef struct
{
    int verNum;            // 图的顶点数
    int edgeNum;           // 图的边数
    VNode adjList[verNum]; // 顶点表
} ALGraph;                 // 邻接表

```

### 十字链表法

十字链表是**有向图**的一种链式存储结构.在十字链表中,有向图的每条弧用一个结点(弧结点)来表示,每个顶点也用一个结点(顶点结点)来表示.
![20240504151721](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504151721.png)
弧结点中有 5 个域:tailvex 和 headvex 两个域分别指示弧尾和弧头这两个顶点的编号:头链域 hlink 指向弧头相同的下一个弧结点:尾链域 tlink 指向弧尾相同的下一个弧结点:info 域存放该弧的相关信息.

**十字链表的本质是邻接表和逆邻接表的组合**,以下图为例:
![20240504160413](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504160413.png)

- 其中红框内的内容表示邻接表,以最上行为例,$V_1 \to V_2,V_1 \to V_3$,在十字链表中的表示为 $0 \to 1 ,0 \to 2$
- 处红色外其他颜色表示该结点的逆邻接表,以$V_1$结点为例,有$V_4,V_3$两点入$V_1$点,因此指向$V_3,V_4$

### 邻接多重表

- 邻接多重表是**无向图**的一种链式存储结构,由顶点表结点和边表结点组成
- 顶点表结点:存储顶点的数据信息和指示第一条依附于该顶点的边
- 边表结点:由六个域组成,`mark`标记域,标记该边是否被搜索过,`ivex`和`jvex`为该边依附的两个顶点
- 在图中的位置,`ilink`指向下一条依附于顶点`ivex`的边,`jlink`指向下一条依附于顶点`jvex`的边,`info`为指向和边相关的信息的指针域

![20240504161026](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504161026.png)

![20240504161051](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504161051.png)

### 图的四种存储方式总结

|                  |              **邻接矩阵**               |                        **邻接表**                         |    **十字链表**    |   **邻接多重表**   |
| :--------------: | :-------------------------------------: | :-------------------------------------------------------: | :----------------: | :----------------: |
|  **空间复杂度**  |              $O(\|V\|^2)$               | 无向图:$O(\|V\|+2\|E\|) \newline$ 有向图:$O(\|V\|+\|E\|)$ | $O(\|V\| + \|E\|)$ | $O(\|V\| + \|E\|)$ |
|   **找相邻边**   | 遍历对应行或列的时间复杂度为 $O(\|V\|)$ |             找有向图的入度必须遍历整个邻接表              |       很方便       |       很方便       |
| **删除边或顶点** |  删除边很方便,删除顶点需要大量移动数据  |               无向图中删除边或顶点都不方便                |       很方便       |       很方便       |
|    **适用于**    |                 稠密图                  |                       稀疏图和其他                        |    只能存有向图    |    只能存无向图    |
|   **表示方式**   |                  唯一                   |                          不唯一                           |       不唯一       |       不唯一       |

## 图的操作

```c++{.line-numbers}
Adjacent(G,x,y):判断图G是否存在边<x,y>或(x,y).
Neighbors(G,x):列出图G中与结点x邻接的边.
InsertVertex(G,x):在图G中插入顶点x.
DeleteVertex(G,x):从图G中删除顶点x.
AddEdge(G,x,y):若无向边(x,y)或有向边<x,y>不存在,则向图G中添加该边.
RemoveEdge(G,x,y): 若无向边(x,y)或有向边<x,y>存在,则从图G中删除该边.
FirstNeighbor(G,x):求图G中顶点x的第一个邻接点,若有则返回顶点号.若x没有邻接点或图中不存在x,则返回-1.
NextNeighbor(G,x,y):假设图G中顶点y是顶点x的一个邻接点,返回除y外顶点x的下一个邻接点的顶点号,若y是x的最后一个邻接点,则返回-1.
Get_edge_value(G,x,y):获取图G中边(x,y)或<x,y>对应的权值.
Set_edge_value(G,x,y,v):设置图G中边(x,y)或<x,y>对应的权值为v.
```

# 图的遍历

## $DFS$

### 算法分析

- $DFS$ 中文名为深度优先搜索,大致来说就是从图中一个节点开始,每次寻找可以前往的下一个点,采用递归调用的方式进行下去的算法.在图遍历的过程当中,$DFS$ 会对其访问过的节克打上标记避免重复访问.
- $DFS$ 过程中,在递归栈中存储的即为起始节点到当前节点的路径.在当前节点找不到节点继续时,会往上回溯.
- 深度优先生成树

### 算法过程

主要伪代码如下:

```c++{.line-numbers}
DFS(v) // v 可以是图中的一个顶点,也可以是抽象的概念,如 dp 状态等.
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end
```

以上代码只包含了 DFS 必需的主要结构.实际的 DFS 会在以上代码基础上加入一些代码,利用 DFS 性质进行其他操作.

该算法通常的时间复杂度为 $O(n+m)$,空间复杂度为 $O(n)$,其中 $n$ 表示点数,$m$ 表示边数.注意空间复杂度包含了栈空间,栈空间的空间复杂度是 $O(n)$ 的.在平均 $O(1)$ 遍历一条边的条件下才能达到此时间复杂度,例如用前向星或邻接表存储图；如果用邻接矩阵则不一定能达到此复杂度,邻接矩阵的时间复杂度为 $O(|V|^2)$.

### 代码实现

- 递归实现,函数在递归调用时的求值如同对栈的添加和删除元素的顺序,故函数调用所占据的虚拟地址被称为函数调用栈(Call Stack),DFS 可用递归的方式实现.以邻接表(Adjacency List)作为图的存储方式:

```c++{.line-numbers}
int n, m;
bool b[N + 1];// 记录该点是否被访问过
vector<int> edge[N + 1];
inline void dfs(int x)
{
    b[x] = true;
    for (auto y : edge[x])
        if (!b[y])
            dfs(y);
}
int main()
{
    ...
    memset(b, false, sizeof(b));
    dfs(s); // s表示起点编号
}
```

- 栈实现

```c++{.line-numbers}
vector<vector<int>> adj; // 邻接表
vector<bool> vis;        // 记录节点是否已经遍历
void dfs(int s)
{
    stack<int> st;
    st.push(s);
    vis[s] = true;
    while (!st.empty())
    {
        int u = st.top();
        st.pop();
        for (int v : adj[u])
            if (!vis[v])
            {
                vis[v] = true; // 确保栈里没有重复元素
                st.push(v);
            }
    }
}
```

### 深度优先生成树和生成森林

连通图调用 $DFS$ 才能产生深度优先生成树,否则就是生成深度优先生成森林.此外,基于邻接表存储的深度优先生成树是不唯一的.
![20240516152953](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240516152953.png)

## $BFS$

### 算法分析

- $BFS$ 中文名为广度优先搜索或宽度优先搜索,大致来说就是从图中一个节点开始,一层一层往外搜索,每次都尝试访问同一层的节点,一层访问完再访问下一层.算法过程可以看做一个逐步扩散的过程,想象在图中有一个点有洪水爆发,慢慢淹没了整张图.
- 从 1 号节点开始遍历整张图,此图中所有边的长度都为 1
- 先将 1 号节点加入 $BFS$ 搜索队列,初始化时它的距离为 0,其它节点的距离为无穷大
- 接下来进行循环操作:
  - 在队列中选择队首节点出队
  - 访问所有和它相邻的节点,如果此节点没有被访问过(如何判断?),就将它加入队列,并且距离等于当前节点的距离加 1;
- 直到队列为空

### 算法过程

```c++{.line-numbers}
BFS(s){
  q = new queue()
  q.push(s), visited[s] = true
  while (!q.empty()) {
    u = q.pop()
    for each edge(u, v) {
      if (!visited[v]) {
        q.push(v)
        visited[v] = true
      }
    }
  }
}
```

具体来说,我们用一个队列 Q 来记录要处理的节点,然后开一个布尔数组 `vis[]` 来标记是否已经访问过某个节点.开始的时候,我们将所有节点的 `vis` 值设为 0,表示没有访问过；然后把起点 s 放入队列 Q 中并将 `vis[s]` 设为 1.之后,我们每次从队列 Q 中取出队首的节点 u,然后把与 u 相邻的所有节点 v 标记为已访问过并放入队列 Q.循环直至当队列 Q 为空,表示 $BFS$ 结束.
在 $BFS$ 的过程中,也可以记录一些额外的信息.例如上述代码中,d 数组用于记录起点到某个节点的最短距离（要经过的最少边数）,p 数组记录是从哪个节点走到当前节点的.有了 d 数组,可以方便地得到起点到一个节点的距离.有了 p 数组,可以方便地还原出起点到一个点的最短路径.上述代码中的 `restore` 函数使用该数组依次输出从起点到节点 x 的最短路径所经过的节点.

遍历图的过程实质上是对每个顶点查找其邻接点的过程,耗费的时间取决于所采用的存储结构.采用邻接表存储时,每个顶点均需搜索(或入队)一次,时间复杂度为 $O(|V|)$,在搜索每个顶点的邻接点时,每条边至少访问一次,时间复杂度为 $O(|E|)$,总的时间复杂度为 $O(|V|+|E|)$.采用邻接矩阵存储时,查找每个顶点的邻接点所需的时间为 $O(|V|)$,总时间复杂度为 $O(|V|^2)$.

### 代码实现

```c++{.line-numbers}
int n, m, dist[N + 1], q[N + 1];// q是队列,dist是距离
vector<int> edge[N + 1];// 链表存边的方式存图
void BFS(int s)
{
    // s表示起点的编号
    memset(dist, 255, sizeof(dist));
    dist[s] = 0;
    int front = 1, rear = 1;
    q[1] = s;
    while (front <= rear)
    {
        int x = q[front];
        ++front;
        for (auto y : edge[x])
        {
            if (dist[y] == -1)
            {
                dist[y] = dist[x] + 1;
                q[++rear] = y;
            }
        }
    }
}
```

### 广度优先生成树

在广度遍历的过程中,我们可以得到一棵遍历树,称为广度优先生成树.需要注意的是,同一个图的邻接矩阵存储表示是唯一的,所以其广度优先生成树也是唯一的,但因为邻接表存储表示不唯一,所以其广度优先生成树也是不唯一的.

![20240516152038](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240516152038.png)

## 遍历与连通性

图的遍历算法可以用来判断图的连通性。对于无向图来说,若无向图是连通的,则从任意一个结点出发,仅需一次遍历就能够访问图中的所有顶点;若无向图是非连通的,则从某一个顶点出发,一次遍历只能访问到该顶点所在连通分量的所有顶点,而对于图中其他连通分量的顶点,则无法通过这次遍历访问。对于有向图来说,若从初始顶点到图中的每个顶点都有路径,则能够访问到图中的所有顶点,否则不能访问到所有顶点。

# 图的应用

## 最小生成树

### 最小生成树的性质

- 若图 G 中存在权值相同的边,则 G 的最小生成树可能不唯一,即最小生成树的树形不唯一。当图 G 中的各边权值互不相等时,G 的最小生成树是唯一的
- 若无向连通图 G 的边数比顶点数少 1,即 G 本身是一棵树时,则 G 的最小生成树就是它本身。
- 虽然最小生成树不唯一,但其对应的边的权值之和总是唯一的,而且是最小的。
- 最小生成树的边数为顶点数减 1。

### $Prim$ 算法

#### 算法解释

![20240518151809](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240518151809.png)

- 定义$dist(u)$表示连接 $C$(注意 $C$ 是点集,换言之是一个图) 中任意点和$u$的边的边权的最小值,我们把$dist(u)$简称为$u$到$C$的距离.以下是具体流程:
- 将任意点 $x$ 加入 $C$,此时 $C$ 中只有一个点 $x$;对于其他点 $y$,如果 $×,y$ 之间有边,则 $dist(y)$等于这些边的边权的最小值,否则 $dist(y)$等于无穷大
- 在每一轮中,将 $dist$ 最小(不能是无穷大)的还不在 $C$ 中的顶点 $z$ 加入 $C$,同时将连接 $C$ 和 $z$ 的边权最小的边加入最小生成树的边集,并且用 $z$ 连出去的边尝试更新其它点的 $dist$
- 当没有新的点加入 $C$ 时,算法结束.此时若所有点都加入了 $C$,意味着我们到了最小生成树,否则意味着图不连通.
- 朴素$Prim$时间复杂度是 $O(n^2+m)$, $n$ 表示点数,$m$ 表示边数

#### 代码实现

```c++ {.line-numbers}
struct Node
{
    int y, v;
    Node(int _y, int _v)
    {
        y = _y;
        v = _v;
    };
};
vector<Node> edge[N];
int n, m, dist[N];
bool b[N]; // b记录的是该点是否加入到了集合C中
int Prim()
{
    memset(b, false, sizeof(b));
    memset(dist, 127, sizeof(dist));
    dist[1] = 0;
    int ans = 0, tot = 0; // ans是当前最小生成树的边权和,tot表示当前集合C中一共有多少点,如果tot==n则存在最小生成树,反之不存在
    for (;;)
    {
        int x = -1; // 不在C中且dist最小的点
        for (int i = 1; i <= n; i++)
            if (!b[i] && dist[i] < 1 << 30)       // 找到一个不在b中,且dist不是无穷大的点
                if (x == -1 || dist[i] < dist[x]) // 如果这个点之前都没有被找到或者并且该点的距离是最小的
                    x = i;
        if (x == -1)
            break; // 没有符合的点,没有新的点可以加入
        ++tot;
        ans += dist[x];
        b[x] = true;
        for (auto i : edge[x])
            dist[i.y] = min(dist[i.y], i.v);// 更新其他边
    }
    if (tot != n)
        return -1;
    else
        return ans;
}
```

### $Kruskal$ 算法

#### 算法解释

![20240518152208](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240518152208.png)

- 与 $Prim$ 不同,$Kruskal$ 是以一条条添加边的形式求最小生成树的
- 为了把一开始 $n$ 个分散的点连成一棵树,$Kruskal$ 算法使用了数据结构中的并查集
- 时间复杂是$O(mlogn)$,n 表示点数,m 表示边数
- 算法流程如下:
  - 初始化并查集,一开始所有点的代表元都是它自己,每个点本身构成了一个集合;
  - 将所有边按照边权从小到天的顺序排序;
  - 按边权从小到大的顺序依次枚举所有边,如果当前这条边连接的两个顶点位于同一个集合(它们的代表元是一样的),则什么都不做,否则
    - 将这条边添加到最小生成树的边集里
    - 将这条边连接的两个点所在的集合合并,这里会用到并查集的合并操作
  - 直到只剩下一个集合,算法结束

#### 代码实现

```c++ {.line-numbers}
struct Node
{
    int x, y, v;
    bool operator<(const Node &A) const
    {
        return v < A.v;
    }
} a[N];
int n, m, fa[N];
int findset(int i)
{
    if (i == fa[i])
        return i;
    return fa[i] = findset(fa[i]);
}
int Kruskal()
{
    for (int i = 1; i <= n; i++)
        fa[i] = i;
    sort(a + 1, a + m + 1);
    int ans = 0, cnt = n; // ans为当前最小生成树权值和,cnt是当前有多少个集合
    for (int i = 1; i <= m; i++)
    {
        int x = findset(a[i].x), y = findset(a[i].y);
        if (x != y)
        {
            fa[x] = y;
            ans += a[i].v;
            --cnt;
        }
        if (cnt == 1)
            break;
    }
    if (cnt != 1)
        return -1;
    else
        return ans;
}
```

## 最短路

### $Dijkstra$算法

#### 原理

- 通常用于解决无负权边图的最短路
- 我们要维护一个顶点集合 $C$,满足对于所有集合 $C$ 中的顶点 $x$,我们都已经找到了起点 $S$ 到 $x$ 的最短路,此时 $dist(x)$记录的就是最终最短路的长度
- 时间复杂是$O(n^2+m)$, **_n_**表示点数,**_m_**表示边数

#### 相关概念

- 对于无向图中的一条边$(u \leftrightarrow v)$,可以看作有向图中两条边$(u \leftrightarrow v)$和$(v \leftrightarrow u)$的结合,我们可以用这种方式将无向图转换成有向图,因此我们接下来介绍的都是有向图上的最短路算法.
- 我们规定以下符号
  - $G=<V,E>$代表我们要处理的简单有向图
  - $n=|V|,m=|E|$代表顶点数和边数(||表示集合中的元素总数)
  - $l(u,v)$代表$u$到$v$的边的长度(边权)
  - $S$表示起点,$T$表示终点
  - $dist(u)$代表我们当前求出的从$S$到$u$的最短路径的长度,后面简称为$u$的距离

#### 算法流程

- 我们要维护一个顶点集合 $C$,满足对于所有集合 $C$ 中的顶点 $X$,我们都已经找到了起点 $S$ 到 $x$ 的最短路,此时 $dist(x)$记录的就是最终最短路的长度
  - 将 $C$ 设置为空,将 $S$ 的距离设置为 0,其余顶点的距离设置为无穷大
  - 在每一轮中,将离起点最近的($dist$ 最小,不能是无限大)的还不在 $C$ 中的顶点加入 $C$,并且用这个点连出去的边通过松弛操作尝试更新其它点的 $dist$
  - 当到达目标终点(如果目标终点存在的话)或者没有新的点加入 $C$ 时,算法结束.

#### 代码实现

```c++ {.line-numbers}
struct Node
{
    int y, v;// y表示该点连到哪里,v表示边权
    Node(int _y, int _v)
    {
        y = _y;
        v = _v;
    };
};
vector<Node> edge[N + 1];
int n, m, dist[N + 1];
bool b[N + 1];
int Dijkstra(int s, int t)
{
    memset(b, false, sizeof(b));
    memset(dist, 127, sizeof(dist));
    dist[s] = 0;
    for (;;)
    {
        int x = -1;// x是当前不在C中且离起始点最近的点的下标
        for (int i = 1; i <= n; i++)
            if (!b[i] & dist[i] < 1 << 30)// 选择出不在C中且距离不是无穷大的点
                if (x == -1 && dist[i] < dist[x])
                    x = i;
        if (x == t || x == -1)// C中没有点可以加进去或已经走到目标点的时候结束循环
            break;
        b[x] = true;// 将该点加入C中并进行松弛操作
        for (auto i : edge[x])
            dist[i.y] = min(dist[i.y], dist[x] + i.v);
    }
    return dist[t];
}
```

### $Floyd$算法

#### 原理

- 时间复杂度是$O(n^3)$,$n$表示点数
- 主要用于求任意两结点之间的最短路
- 适用于任何图,不管有向无向,边权正负,但是最短路必须存在(不能有个负环)

#### 代码

```c++ {.line-numbers}
memset(f, 127, sizeof(f));
f[0][i][j] = a[i][j]; // a数组为存储有向图边权的矩阵,若存在从i到j的边,a[i][j]记录的是这些边的边权的最小值,若不存在从i到j的边,a[i][j]为无穷大;对于所有i,a[i][i]=0
for (int k = 1; k <= n; k++)
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            f[k][i][j] = min(f[k - 1][i][j], f[k - 1][i][k] + f[k - 1][k][j]);
```

- $f[k][i][j]$表示从$i$到$j$,中间可以经过$1 \sim k$**号**顶点的最短路径的长度
- 最终的迭代中,可以知道的是,$f[k][i][j]$的最小值取不取有两种情况,最小值要么经过 $k$ **号**顶点,要么不经过 $k$ **号**顶点,从这两种情况中取得$f[k][i][j]$的最小值
- $f[n][u][v]$即为从$u$到$v$的最短路径的长度,因为其本意应为从$i$到$j$中间经过$n$个顶点的最短长度,而一共只有$n$个顶点,所以应为从$u$到$v$的最短路径长度,若等于无穷大则表示不存在从$u$到$v$的路径

## 拓扑排序

![20240518154232](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240518154232.png)

- **有向无环图**:若一个有向图中不存在环,则称为有向无环图,简称 DAG 图
- 如果用 DAG 图表示一个工程,其顶点表示活动, 用有向边 $<a,b>$ 表示 a 活动必须早于 b 活动进行, 那么我们将它叫做 **AOV 网**(顶点表示活动的网络)

### 拓扑排序简介

- 时间复杂度 $O(n+m)$, $n$表示点数,$m$表示边数
- 拓扑排序$(Topological Sorting, TopoSort)$是对有向无环图$(DAG, Directed Acyclic Graph)$的顶点进行的一种线性排序,排序序列中每个顶点都会且仅会出现一次,且对于所有有向边$u \to v$,排完序后 $u$ 都在 $v$ 前面
  - 举例:学完预备课才可以学基础课,学完基础课才可以学提高课,这是一个三点二边的图,如果该图闭环,那么寄了.如果改图顺序不对,那也寄了.因此如果想要有拓扑排序,就必须是有向无环图.
- 一个有向无环图可能存在多种有向无环图拓扑排序的结果,如下
  ![20240518154724](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240518154724.png)

### 排序流程

- 在拓扑排序中,我们用队列 $L$ 记录到目前为止的拓扑序列,用集合 $S$ 记录所有不在 $L$ 中的入度为 0 的顶点
- 首先遍历整张图上的顶点,如果一个顶点的入度为 0,将它加入 $S$;
- 当 $S$ 不为空时
  - 在 $S$ 中任取一个顶点 $x$,将 $x$ 加入到队列 $L$ 的队尾,并把 $x$ 从 $S$ 中删去
  - 遍历从 $x$ 出发的边$x \to y$,把这条边删掉,如果 $y$ 的入度变成了 0 则将其加入到 $S$ 中
- 循环结束时,如果所有点都加入了 $L$,那么我们就找到了一个合法的拓扑序列,否则可以证明图中存在环；
- $L,S$ 一般是用同一个队列实现

#### 模板

```c++ {.line-numbers}
vector<int> edge[N];
int n, m, q[N], d[N]; // d记录了每个点一开始的入度
inline void TopoSort()
{
    int front = 1, rear = 0;
    for (int i = 1; i <= n; i++)
        if(!d[i])
            q[++rear] = i;// 将所有入度为0的点加入q中
    while (front <= rear)
    {
        int x = q[front];
        ++front; // 出队
        for (auto y : edge[x]) // 减边
            if (--d[y] == 0)
                q[++rear] = y;
    }
    if (rear == n)
        // 存在合法拓扑序
    else
    // 存在不合法拓扑序
}
```

### 关键路径

![20240518161917](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240518161917.png)

- AOE 网:以顶点表示事件,以有向边表示活动,边上的权值表示完成该活动的开销的带权有向图。(用边表示活动的网络)
- AOE 网的两个重要性质:
  - 只有在某顶点表示的事件发生后,从该顶点出发的各有向边所代表的活动才能开始;
  - 只有进入某顶点的所有有向边所代表的活动都完成时,该顶点所代表的事件才能发生
- 从开始顶点到结束顶点的路径中,路径长度最大的那条路径我们称之为关键路径。关键路径上的活动我们称之为关键活动。
- 关键路径的意义在于, 当我们按这个路径将关键活动全部完成时, 其他所有活动也可以并行完成。如果边上的权值代表完成这项活动的时间, 那么关键路径的总权值就代表整个工程完成的最短时间。
- 事件$\mathrm{v}_{\mathrm{k}}$的最早发生时间 ve(k):从源点 1 到顶点$\mathrm{v}_{\mathrm{k}}$的最长路径长度。
- 事件$\mathbf{v}_k$的最晚发生时间 vl(k):在不推迟整个工程完成的前提下，保证它的后继事件$\mathbf{v}_{j}$在其最晚发生时间可以发生时，该事件必须发生的时间。
- 活动$\mathrm{a}_{\mathrm{i}}$的最早开始时间 e(i):该活动弧的起点所表示的事件最早发生时间。
- 活动$\mathrm{a}_\mathrm{i}$的最迟开始时间 I(i):该活动弧的终点所表示的事件的最晚发生时间与该活动所需事件之差。
- 求关键路径的算法步骤如下：
  - 从源点出发，令 $\nu_e($源点)=0, 按拓扑有序求其余顶点的最早发生时间 $\nu_e()$。
  - 从汇点出发，令 $v_t($汇点$)=v_e($汇点), 按逆拓扑有序求其余顶点的最迟发生时间 $\nu_t()$
  - 根据各顶点的 $v_e()$值求所有弧的最早开始时间 $e()$。
  - 根据各顶点的 $v_{l}()$值求所有弧的最迟开始时间 $l()$。
  - 求 AOE 网中所有活动的差额$d()$,找出所有$d()=0$的活动构成关键路径。
