# 图的基本概念

## 图的定义

- 图的定义: 图 (graph) 是一个二元组 $G=(V(G), E(G))$.其中 $V(G)$ 是非空集,称为 点集(vertex set),对于 $V$ 中的每个元素,我们称其为 顶点 (vertex)或节点 (node),简称点; $E(G)$ 为 $V(G)$ 各结点之间边的集合,称为边集(edge set).常用 $G=(V,E)$ 表示图.
- 有向图与无向图
  - 有向图的定义:若$E$是有向边(也称弧)的有限集合,则图$G$为有向图.弧是顶点的有序对,记为$<v,w>$.其中$v,w$ 是顶点,$v$称为弧尾,$w$称为弧头,$<v,w>$称为从$v$到$w$ 的弧,也称$v$邻接到$w$.
  - 无向图的定义:若 $E$ 是无向边(简称边)的有限集合,则图 $G$ 为无向图.边是顶点的无序对,记为 $(v,w)$ 或 $(w,v)$.可以说 $w$ 和 $v$ 互为邻接点.边$(v,w)$依附于$w$ 和 $v$,或称边 $(v,w)$ 和 $v,w$ 相关联.
- 简单图,多重图

  - 简单图(simple graph):若一个图中没有顶点到自身的环和重复的边,它被称为简单图
  - 多重图:如果一张图中有自环或重边,则称它为多重图(multigraph)
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503224023.png" width = 20%/></div>

- 完全图与竞赛图:

  - 完全图(无向图):设 $G$ 为一个有 $n$ 个节点的无向简单图,若 $G$ 中每个顶点都与其余 $n-1$ 个顶点有边相连,则称 $G$ 为 n 阶无向完全图,简称为 $n$ 阶完全图,记做$K_n$,边与点的关系是$\dfrac{n*(n-1)}{2}$
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503221330.png" width = 20%/></div>

  - 完全图(有向图):设 $G$ 为一个有 $n$ 个节点的有向简单图,若 $G$ 中每个顶点都有连到其余 $n-1$ 个顶点的边,且都有这些节点连向它的边,则称 $G$ 为 $n$ 阶有向完全图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503221358.png" width = 20%/></div>

  - 竞赛图:基于 $n$ 阶无向完全图,给每条边任意确定一个方向形成的图称为 $n$ 阶竞赛图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503221615.png" width = 20%/></div>

- 子图:设$G=<V,E>,G'=<V',E'>$ 为两个图(同为无向图或有向图),如果$V' \subseteq V$且$E'\subseteq E$,则称图 $G'$为图$G$的子图,$G$称为图$G'$的母图,记作$G'\subseteq G$

  - 子图有可能和自己一模一样,但是真子图不可能一模一样
  - 如果$V'=V,$则称$G'$为$G$的生成子图(点数一样但是边数不一样)
  - 如果$V'\subset V$或$E' \subset E$,则称$G'$为$G$的真子图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503222126.png" width = 70%/></div>

- 稠密图,稀疏图:
  - 稠密图:若一张图的边数远小于其点数的平方,那么它是一张稀疏图 (sparse graph)
  - 若一张图的边数接近其点数的平方,那么它是一张稠密图 (dense graph)
  - 这两个概念并没有严格的定义,一般用于讨论时间复杂度为 $O(|V|^2)$ 的算法与 $O(|E|)$ 的算法的效率差异(在稠密图上这两种算法效率相当,而在稀疏图上 $O(|E|)$ 的算法效率明显更高)
- <font color="red">连通,连通图,连通分量</font>
  - 在无向图中,若从顶点$v$到顶点$w$有路径存在,则称$v$和$w$是连通的.若图$G$中任意两个顶点都是连通的,则称图$G$为连通图,否则称为非连通图.无向图中的极大连通子图称为连通分量.
- 生成树,生成森林:
  - 生成树:(针对无向图):连通图的生成树是包含图中全部顶点的一个极小连通子图.若图中的顶点数为$n$,则它的生成树有$n-1$条边,生成树不一定唯一.
    ![20240503230757](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503230757.png)
  - 生成森林:非连通图中,连通分量的生成树构成了非连通图的生成森林

> 概念辨析:极大连通子图,极小连通子图,连通分量,生成树,生成森林
>
> <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504125057.png" width = 70%/></div>
> 如图:c是一个非连通图,其由a和b两个连通图组成,对于c来说,a和b是它的两个连通分量,a和b分别是两棵生成树,共同组成了生成森林.

## 图的基本术语

- 顶点的度,出度和入度:
  - 顶点的度:图中以该顶点为一个端点的边的数目
  - 无向图中顶点$v$的度是指依附于该顶点的边的条数,记为 $TD(v)$.具有$n$个顶点,$e$条边的无向图中,所有顶点的度总和是边数的二倍,即 $\sum_{i=1}^nTD(v_i)=2e$
  - 有向图中顶点$v$的度分为入度和出度.入度是以顶点 v 为终点的有向边的条数记为$ID(v)$
  - 出度是以顶点$v$为起点的有向边的数目,记为 $OD(v)$.具有$n$个顶点,$e$条边的有向图中,全部顶点的入度之和与出度之和相等,等于边数.即$\sum_{i=1}^n ID(v_i)=\sum_{i=1}^n OD(v_i)=e$
- 路径和路径长度,简单路径:
  - 路径:在图中,顶点 $\mathrm{V_p}$ 到顶点 $\mathrm{V_q}$ 之间的顶点序列 $\mathrm{V_p},\mathrm{V_a},\mathrm{V_b}...\mathrm{V_q}$
  - 路径长度:路径上边的数目,若该路径最短则称之为距离
  - 简单路径:序列中顶点不重复出现的路径,而且自身不存在环
- 边的权,网络(带权图):
  - 权:图中边具有与之相关的数值,称之为权重,权重可以表示从一个顶点到另一个顶点的距离、花费的代价等
  - 这种带权图也叫做网络
- 回路(环):第一个顶点和最后一个顶点相同的路径.注意:若无向图有 $n$ 个顶点,并且有大于 $n-1$ 条边,则此图一定有环
- <font color="red">强连通,强连通图,强连通分量</font>:
  - 强连通:有向图中,看从顶点 $v$ 到顺点 $w$ 和顶点 $w$ 到顶点 $V$ 之间都有路径,则称 $v$ 和 $w$ 是强连通的
  - 强连通图:有向图 $G$ 中任意两个顶点都是强连通的
  - 强连通分量:有向图中的极大强连通子图
  <div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240503231457.png" width = 80%/></div>

# 图的存储和操作

## <font color="red">图的存储</font>

### 邻接矩阵

所谓邻接矩阵存储,是指用一个一维数组存储图中顶点的信息,用一个二维数组存储图中边的信息(即各顶点之间的邻接关系),存储顶点之间邻接关系的二维数组称为邻接矩阵.
顶点数为$n$ 的图 $G=(V,E)$的邻接矩阵 $A$ 是$n\times n$ 的,将$G$ 的顶点编号为$v_1,v_2,\cdots,v_n$, 则

$$
  A[i][j]=\begin{cases}1,&(v_i,v_j)\text{或}\langle v_i,v_j\rangle\text{是}E(G)\text{中的边}\\0或\infty,&(v_i,v_j)\text{或}\langle v_i,v_j\rangle\text{不是}E(G)\text{中的边}\end{cases}
$$

<div align=center> <img src="https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504131630.png" width = 80%/></div>

```c++{.line-numbers}
typedef char VertexType; // 顶点信息对应的数据类型
typedef int EdgeType;    // 边信息对应的数据类型
typedef struct
{
    int verNum;                     // 顶点数
    int edgeNum;                    // 边数
    VerType vertex[verNum];         // 顶点信息(一维数组)
    EdgeType edges[verNum][verNum]; // 边信息(二维数组)
}MGraph;
```

### 邻接表

**图的邻接表存储方式是指对具有 $n$ 个顶点的图,建立 $n$ 条对应的单链表**,这些单链表称为**边表**.每个单链表的第一个结点称为头结点,存放顶点相关的信息.每个单链表中除了头结点外的其他结点,称为边结点,存放以头结点为起点的边的信息.
将 $n$ 个单链表的头结点存放在一个一维数组中,这个一维数组称为**顶点表**.单链表的头结点, 也称为顶点表结点.

![20240504143850](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504143850.png)
顶点表结点由两个域组成:顶点域(data)存储顶点 $v_i$ 的相关信息,边表头指针域 (firstarc)指向第一条边的边表结点.边表结点至少由两个域组成:邻接点域(adivex)在储与头结点顶点,邻接的顶点编号,指针域 (nextarc)指向下一条边的边表结点.
![20240504144339](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504144339.png)

```c++{.line-numbers}
typedef struct edgeNode // 边结点
{
    int adjVex;               // 与对应头结点邻接的顶点编号
    struct edgeNode *nextArc; // 指向下一个边结点的指针
    infoType info;            // 可有可无,对于带权图可存储边的权值
} edgeNode;
typedef struct // 头结点
{
    VerType data;       // 顶点信息
    edgeNode *firstArc; // 指向第一个邻接点的指针
} VNode;
typedef struct
{
    int verNum;            // 图的顶点数
    int edgeNum;           // 图的边数
    VNode adjList[verNum]; // 顶点表
} ALGraph;                 // 邻接表

```

### 十字链表法

十字链表是**有向图**的一种链式存储结构.在十字链表中,有向图的每条弧用一个结点(弧结点)来表示,每个顶点也用一个结点(顶点结点)来表示.
![20240504151721](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504151721.png)
弧结点中有 5 个域:tailvex 和 headvex 两个域分别指示弧尾和弧头这两个顶点的编号:头链域 hlink 指向弧头相同的下一个弧结点:尾链域 tlink 指向弧尾相同的下一个弧结点:info 域存放该弧的相关信息.

**十字链表的本质是邻接表和逆邻接表的组合**,以下图为例:
![20240504160413](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504160413.png)

- 其中红框内的内容表示邻接表,以最上行为例,$V_1 \to V_2,V_1 \to V_3$,在十字链表中的表示为 $0 \to 1 ,0 \to 2$
- 处红色外其他颜色表示该结点的逆邻接表,以$V_1$结点为例,有$V_4,V_3$两点入$V_1$点,因此指向$V_3,V_4$

### 邻接多重表

- 邻接多重表是**无向图**的一种链式存储结构,由顶点表结点和边表结点组成
- 顶点表结点:存储顶点的数据信息和指示第一条依附于该顶点的边
- 边表结点:由六个域组成,`mark`标记域,标记该边是否被搜索过,`ivex`和`jvex`为该边依附的两个顶点
- 在图中的位置,`ilink`指向下一条依附于顶点`ivex`的边,`jlink`指向下一条依附于顶点`jvex`的边,`info`为指向和边相关的信息的指针域

![20240504161026](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504161026.png)

![20240504161051](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240504161051.png)

### 图的四种存储方式总结

|                  |              **邻接矩阵**               |                        **邻接表**                         |    **十字链表**    |   **邻接多重表**   |
| :--------------: | :-------------------------------------: | :-------------------------------------------------------: | :----------------: | :----------------: |
|  **空间复杂度**  |              $O(\|V\|^2)$               | 无向图:$O(\|V\|+2\|E\|) \newline$ 有向图:$O(\|V\|+\|E\|)$ | $O(\|V\| + \|E\|)$ | $O(\|V\| + \|E\|)$ |
|   **找相邻边**   | 遍历对应行或列的时间复杂度为 $O(\|V\|)$ |             找有向图的入度必须遍历整个邻接表              |       很方便       |       很方便       |
| **删除边或顶点** |  删除边很方便,删除顶点需要大量移动数据  |               无向图中删除边或顶点都不方便                |       很方便       |       很方便       |
|    **适用于**    |                 稠密图                  |                       稀疏图和其他                        |    只能存有向图    |    只能存无向图    |
|   **表示方式**   |                  唯一                   |                          不唯一                           |       不唯一       |       不唯一       |

## 图的操作

```c++{.line-numbers}
Adjacent(G,x,y):判断图G是否存在边<x,y>或(x,y).
Neighbors(G,x):列出图G中与结点x邻接的边.
InsertVertex(G,x):在图G中插入顶点x.
DeleteVertex(G,x):从图G中删除顶点x.
AddEdge(G,x,y):若无向边(x,y)或有向边<x,y>不存在,则向图G中添加该边.
RemoveEdge(G,x,y): 若无向边(x,y)或有向边<x,y>存在,则从图G中删除该边.
FirstNeighbor(G,x):求图G中顶点x的第一个邻接点,若有则返回顶点号.若x没有邻接点或图中不存在x,则返回-1.
NextNeighbor(G,x,y):假设图G中顶点y是顶点x的一个邻接点,返回除y外顶点x的下一个邻接点的顶点号,若y是x的最后一个邻接点,则返回-1.
Get_edge_value(G,x,y):获取图G中边(x,y)或<x,y>对应的权值.
Set_edge_value(G,x,y,v):设置图G中边(x,y)或<x,y>对应的权值为v.
```

# 图的遍历

## $DFS$

### 算法分析

- $DFS$ 中文名为深度优先搜索,大致来说就是从图中一个节点开始,每次寻找可以前往的下一个点,采用递归调用的方式进行下去的算法.在图遍历的过程当中,$DFS$ 会对其访问过的节克打上标记避免重复访问.
- $DFS$ 过程中,在递归栈中存储的即为起始节点到当前节点的路径.在当前节点找不到节点继续时,会往上回溯.
- 深度优先生成树

### 算法过程

主要伪代码如下:

```c++{.line-numbers}
DFS(v) // v 可以是图中的一个顶点,也可以是抽象的概念,如 dp 状态等.
  在 v 上打访问标记
  for u in v 的相邻节点
    if u 没有打过访问标记 then
      DFS(u)
    end
  end
end
```

以上代码只包含了 DFS 必需的主要结构.实际的 DFS 会在以上代码基础上加入一些代码,利用 DFS 性质进行其他操作.

该算法通常的时间复杂度为 $O(n+m)$,空间复杂度为 $O(n)$,其中 $n$ 表示点数,$m$ 表示边数.注意空间复杂度包含了栈空间,栈空间的空间复杂度是 $O(n)$ 的.在平均 $O(1)$ 遍历一条边的条件下才能达到此时间复杂度,例如用前向星或邻接表存储图；如果用邻接矩阵则不一定能达到此复杂度,邻接矩阵的时间复杂度为 $O(|V|^2)$.

### 代码实现

- 递归实现,函数在递归调用时的求值如同对栈的添加和删除元素的顺序,故函数调用所占据的虚拟地址被称为函数调用栈(Call Stack),DFS 可用递归的方式实现.以邻接表(Adjacency List)作为图的存储方式:

```c++{.line-numbers}
int n, m;
bool b[N + 1];// 记录该点是否被访问过
vector<int> edge[N + 1];
inline void dfs(int x)
{
    b[x] = true;
    for (auto y : edge[x])
        if (!b[y])
            dfs(y);
}
int main()
{
    ...
    memset(b, false, sizeof(b));
    dfs(s); // s表示起点编号
}
```

- 栈实现

```c++{.line-numbers}
vector<vector<int>> adj; // 邻接表
vector<bool> vis;        // 记录节点是否已经遍历
void dfs(int s)
{
    stack<int> st;
    st.push(s);
    vis[s] = true;
    while (!st.empty())
    {
        int u = st.top();
        st.pop();
        for (int v : adj[u])
            if (!vis[v])
            {
                vis[v] = true; // 确保栈里没有重复元素
                st.push(v);
            }
    }
}
```

### 深度优先生成树和生成森林

连通图调用 $DFS$ 才能产生深度优先生成树,否则就是生成深度优先生成森林.此外,基于邻接表存储的深度优先生成树是不唯一的.
![20240516152953](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240516152953.png)

## $BFS$

### 算法分析

- $BFS$ 中文名为广度优先搜索或宽度优先搜索,大致来说就是从图中一个节点开始,一层一层往外搜索,每次都尝试访问同一层的节点,一层访问完再访问下一层.算法过程可以看做一个逐步扩散的过程,想象在图中有一个点有洪水爆发,慢慢淹没了整张图.
- 从 1 号节点开始遍历整张图,此图中所有边的长度都为 1
- 先将 1 号节点加入 $BFS$ 搜索队列,初始化时它的距离为 0,其它节点的距离为无穷大
- 接下来进行循环操作:
  - 在队列中选择队首节点出队
  - 访问所有和它相邻的节点,如果此节点没有被访问过(如何判断?),就将它加入队列,并且距离等于当前节点的距离加 1;
- 直到队列为空

### 算法过程

```c++{.line-numbers}
BFS(s){
  q = new queue()
  q.push(s), visited[s] = true
  while (!q.empty()) {
    u = q.pop()
    for each edge(u, v) {
      if (!visited[v]) {
        q.push(v)
        visited[v] = true
      }
    }
  }
}
```

具体来说,我们用一个队列 Q 来记录要处理的节点,然后开一个布尔数组 `vis[]` 来标记是否已经访问过某个节点.开始的时候,我们将所有节点的 `vis` 值设为 0,表示没有访问过；然后把起点 s 放入队列 Q 中并将 `vis[s]` 设为 1.之后,我们每次从队列 Q 中取出队首的节点 u,然后把与 u 相邻的所有节点 v 标记为已访问过并放入队列 Q.循环直至当队列 Q 为空,表示 $BFS$ 结束.
在 $BFS$ 的过程中,也可以记录一些额外的信息.例如上述代码中,d 数组用于记录起点到某个节点的最短距离（要经过的最少边数）,p 数组记录是从哪个节点走到当前节点的.有了 d 数组,可以方便地得到起点到一个节点的距离.有了 p 数组,可以方便地还原出起点到一个点的最短路径.上述代码中的 `restore` 函数使用该数组依次输出从起点到节点 x 的最短路径所经过的节点.

遍历图的过程实质上是对每个顶点查找其邻接点的过程,耗费的时间取决于所采用的存储结构.采用邻接表存储时,每个顶点均需搜索(或入队)一次,时间复杂度为 $O(|V|)$,在搜索每个顶点的邻接点时,每条边至少访问一次,时间复杂度为 $O(|E|)$,总的时间复杂度为 $O(|V|+|E|)$.采用邻接矩阵存储时,查找每个顶点的邻接点所需的时间为 $O(|V|)$,总时间复杂度为 $O(|V|^2)$.

### 代码实现

```c++{.line-numbers}
int n, m, dist[N + 1], q[N + 1];// q是队列,dist是距离
vector<int> edge[N + 1];// 链表存边的方式存图
void BFS(int s)
{
    // s表示起点的编号
    memset(dist, 255, sizeof(dist));
    dist[s] = 0;
    int front = 1, rear = 1;
    q[1] = s;
    while (front <= rear)
    {
        int x = q[front];
        ++front;
        for (auto y : edge[x])
        {
            if (dist[y] == -1)
            {
                dist[y] = dist[x] + 1;
                q[++rear] = y;
            }
        }
    }
}
```

### 广度优先生成树

在广度遍历的过程中,我们可以得到一棵遍历树,称为广度优先生成树.需要注意的是,同一个图的邻接矩阵存储表示是唯一的,所以其广度优先生成树也是唯一的,但因为邻接表存储表示不唯一,所以其广度优先生成树也是不唯一的.

![20240516152038](https://yjc-figure.oss-cn-beijing.aliyuncs.com/20240516152038.png)

## 遍历与连通性

图的遍历算法可以用来判断图的连通性。对于无向图来说,若无向图是连通的,则从任意一个结点出发,仅需一次遍历就能够访问图中的所有顶点;若无向图是非连通的,则从某一个顶点出发,一次遍历只能访问到该顶点所在连通分量的所有顶点,而对于图中其他连通分量的顶点,则无法通过这次遍历访问。对于有向图来说,若从初始顶点到图中的每个顶点都有路径,则能够访问到图中的所有顶点,否则不能访问到所有顶点。

# 图的应用

## 最短路

### $BFS$求最短路

### $Dijkstra$算法

### $Floyd$算法

## 最小生成树

### 最小生成树的性质

### $Prim$ 算法

### $Kruskal$ 算法

## 有向无环图

## 拓扑排序

## 关键路径
