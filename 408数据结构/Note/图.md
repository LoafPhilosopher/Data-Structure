# 图的基本概念

- 一个图是由点集 $V$ 和边集 $E$ 组成的,一般我们会记做图 $G=<V,E>$,一条边连接两个顶点
- 点集 $V$ 中包含了所有顶点,边集 $E$ 中包含了所有边,点集 $V$ 为空时称为空图
- 全部由无向边构成的图称为无向图,由有向边构成的图称为有向图,有向边可以理解为单行道
- 特殊结构
  - 自环:边连接的两个点是同一个点
  - 重边:无向图中指在两点之间有多条边(≥2)连接,如果是有向图则是在两点之间有多条同方向的边(≥2)连接
  - 简单图:没有自环和重边的图称为简单图
- 度数

  - 无向图的度数:对于无向图中的顶点 $v$,连接 $v$ 的顶点的边有几条,$v$ 的度数就是几
  - 有向图的度数:对于有向图的顶点 $v$,$v$ 指出几个点,那它的出度就是几,指入几条边,那它的入度就是几.出度+入度的和即为有向图的度数
  - 度数和等于边数和的两倍,有向图所有顶点的出度和等于入读和

- 完全图和竞赛图

  - 完全图(无向图):设 $G$ 为一个有 $n$ 个节点的无向简单图,若 $G$ 中每个顶点都与其余 $n-1$ 个顶点有边相连,则称 $G$ 为**n 阶无向完全图**,简称为 $n$ 阶完全图,记做$K_n$,边与点的关系是$n*(n-1)/2$

  <center><img src="../images/af9f44662a5b4731472cde9ad0987897bd195f8861d7fc26c2a92d3c5ae4c6a7.png" alt="图 3" style="zoom: 50%;" /></center>

- 完全图(有向图):设 $G$ 为一个有 $n$ 个节点的有向简单图,若 $G$ 中每个顶点都有连到其余 $n-1$ 个顶点的边,且都有这些节点连向它的边,则称 $G$ 为 $n$ 阶有向完全图

  <center><img src="../images/4a2c9c97775b440d5807cdbcce1dedd92bfe40223ff644364a6a03a6b0e6074e.png" alt="图 4" style="zoom:50%;" /></center>

- 竞赛图:**基于 n 阶无向完全图**,给每条边任意确定一个方向形成的图称为 $n$ 阶竞赛图

  <center><img src="../images/cbe075d72e8089782499e1316506639bcf91a20b6df129f3338601d4db00baf1.png" alt="图 5" style="zoom:50%;" /></center>

## 子图和生成子图

- 子图:设$G=<V,E>,G'=<V',E'>$ 为两个图(同为无向图或有向图),如果$V' \subseteq V$且$E'\subseteq E$,则称图 $G'$为图$G$的子图,$G$称为图$G'$的母图,记作$G'\subseteq G$
- 如果$V'=V,$则称$G'$为$G$的**生成子图**(点数一样但是边数不一样)
- 如果$V'\subset V$或$E' \subset E$,则称$G'$为$G$的**真子图**

  <center><img src="../images/ec761b7006c5c889b65dc98709e9963e65be58d9c226e59a74ba5597cb578c74.png" alt="图 6" style="zoom:50%;" /></center>

- 子图有可能和自己一模一样,但是真子图不可能一模一样

## 补图

- 补图:设$G=<V,E>$是一个阶无向简单图,以$V$为顶点集,以所有使$G$成为完全图$K_n$,需要添加的边的集合为边集的图,称为$G$的补图,记做$\overline{\text{G}}$
- 简单来说,图和它的补图顶点集相同；边集的交集为空,并集是完全图的边集
- 补图上的边画到图上可以组成一个完全图

  <center><img src="../images/3150fe9f3a38792d6a2c76122598dedf9155e02aee31ff47c85d7bfb789be021.png" alt="图 7" style="zoom:50%;" /></center>

## 同构

- 定义:设$G$和$G'$是分别具有顶点集$V$和$V'$的两个图.如果存在一个双射$h : V \to V' $,满足当且仅当$(v_i,v_j)$是$G$的边时,$(h(v_i),h(v_j))$是$G'$的边,则称图$G$和$G'$同构
  <center><img src="../images/2710a95240fa4ac55e9f123632ac6924778145494941021bba9bde936acad789.png" alt="图 1" style="zoom:40%;" /></center>

  > 两图同构.解释:$a$ 对应点 $a'$,这两点度都为 3,$b$ 对应点 $b'$这两点度都为 2,$c$ 对应点 $c'$这两点度都为 2,$d$ 对应点为 $d'$这两点度都为 2,$e$ 对应点 $e'$这两点度都为 3

## 通路,回路,路径和距离

### 通路

对于一个图 $G$,$G$ 中顶点与边的交替序列$v_0e_1v_1e_2v_2...e_nv_n$称为$v_0$到$v_n$的通路,其中$v_0,v_n$称为通路的起点和终点,通路中变的条数称为它的长度.需要注意的是在有向图中,其方向需保持一致(即可以从起点走到终点即可)
如下图所示

<center><img src="../images/a8bc02242964935ae9a5ba5f934b0b177d7b22388fb400feb21d3172b5884151.png" alt="图 2" style="zoom:50%;" /></center>

其中点和边的关系为,点数 +1 等于边数

### 回路

- 对于一个通路,如果$v_0=v_n$,则称为回路(从起点又走回去了).如果$v_0=v_n$且其他所有顶点都不相同,则成为环

### 路径

- 如果通路中的所有边都不相同,称为迹.如果通路中的所有顶点都不相同,边也各不相同,则称为路径

### 距离

- 图中连接两点之间最短的路径长度称为距离

## 连通性与连通块

### 无向图

- 连通性:设无向图$G=<V,E>,u,v\in V$,如果$u,v$之间存在通路,则称$u,v$是连通的.对于$\forall v \in V$,$v$和$v$自己是连通的(其中存在空路)
- 连通图:对于任意非空无向图$G$,若$G$中任意两个顶点都是连通的,则称$G$为连通图
- 连通块:对于无向图$G$的一个连通子图$H$,如果不存在$F$满足$H \subset F \subseteq G$且$F$为连通图,则称$H$是$G$的一个连通块/连通分量,$H$是一个极大连通子图

  > 解释:连通分量不是简单的子图连接,除了要求子图连接外,还要求子图最大,其中极大的意思是要求子图包含其原来所有的边,以下图为例<img src="../images/17a31356d8a1fa2d7d57e35381277bbbe24be19515dd6521adfe23a1d32aa4e2.png" alt="图 3" style="zoom: 50%;" />

### 有向图

- 连通性:设有向图$G=<V,E>,u,v \in V$,如果存在$u$到$v$的通路,则称$u$可达$v$.如果$u,v$相互可达,则称$u,v$连通
- 强连通:如果有向图$G$中的顶点两两可达,则称$G$为强连通图

## 图的定义

# 图的存储和操作

## 图的存储

### 邻接矩阵

- 无向图的邻接矩阵 $A$:在简单图中,如果顶点$u$和顶点$v$之间存在一条边,则$A[u][v]=A[v][u]=1$.如果没有则$A[u][v]=A[v][u]=0$.对于有重边的情况,如果顶点$u$和顶点$v$之间存在$k$条边,则$A[u][v]=A[v][u]=k$

  <center><img src="../images/e38c18c39e8f9fadeb32ded83d9537d49f356f3684ca035925359a68b17ec438.png" alt="图 4" style="zoom: 40%;" /></center>

- 对于有向图,如果存在一条顶点$u$到顶点$v$的边,则$A[u][v]$在原来的基础上加一

```c++ {.line-numbers}

int n, m;
int a[N + 1][N + 1];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        a[x][y] = a[y][x] = 1;//无向简单图
    }
}
```

### 邻接表

- 邻接表:当一张图节点数比较多,使用邻接矩阵存储所需空间过多时,我们会采用邻接表的形式每个节点下挂一张链表,储存从这个节点连出的边或能够到达的点.

```c++ {.line-numbers}

//记录点的信息
int n, m;
vector<int> edge[N + 1];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= m; i++)
    {
        int x, y;
        cin >> x >> y;
        edge[x].push_back(y);
        edge[y].push_back(x);
    }
}
//记录边的信息
struct Node
{
    Node *next;//记录当前链表的下一个节点的位置,使用.next访问
    int where;//记录可以走到哪一个点
} * head[N + 1], a[2 * M + 1]; // head是链表头指针,a中记录链表中的节点
void addedge(int x, int y)
{
    a[++l].where = y;
    a[l].next = head[x];
    head[x] = &a[l];
}
```

## 图的操作

# 图的遍历

## BFS

## DFS

## 遍历与连通性

# 图的应用

## 最短路

## 最小生成树

## 拓扑序
